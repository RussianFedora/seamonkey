Bug 485217 - Pop the eval context before returning. r+sr=peterv

diff --git a/extensions/transformiix/source/xslt/functions/txKeyFunctionCall.cpp b/extensions/transformiix/source/xslt/functions/txKeyFunctionCall.cpp
--- a/extensions/transformiix/source/xslt/functions/txKeyFunctionCall.cpp
+++ b/extensions/transformiix/source/xslt/functions/txKeyFunctionCall.cpp
@@ -408,20 +408,19 @@ nsresult txXSLKey::testNode(const txXPat
         if (key->matchPattern->matches(aNode, &aEs)) {
             txSingleNodeContext evalContext(aNode, &aEs);
             nsresult rv = aEs.pushEvalContext(&evalContext);
             NS_ENSURE_SUCCESS(rv, rv);
 
             nsRefPtr<txAExprResult> exprResult;
             rv = key->useExpr->evaluate(&evalContext,
                                         getter_AddRefs(exprResult));
+            aEs.popEvalContext();
             NS_ENSURE_SUCCESS(rv, rv);
 
-            aEs.popEvalContext();
-
             if (exprResult->getResultType() == txAExprResult::NODESET) {
                 txNodeSet* res = NS_STATIC_CAST(txNodeSet*,
                                                 NS_STATIC_CAST(txAExprResult*,
                                                                exprResult));
                 PRInt32 i;
                 for (i = 0; i < res->size(); ++i) {
                     val.Truncate();
                     txXPathNodeUtils::appendNodeValue(res->get(i), val);

Bug 485286 - Allocate all of these consistently. r+sr=peterv/sicking a=ss

diff --git a/extensions/transformiix/source/xslt/functions/txKeyFunctionCall.cpp b/extensions/transformiix/source/xslt/functions/txKeyFunctionCall.cpp
--- a/extensions/transformiix/source/xslt/functions/txKeyFunctionCall.cpp
+++ b/extensions/transformiix/source/xslt/functions/txKeyFunctionCall.cpp
@@ -401,26 +401,30 @@ nsresult txXSLKey::testNode(const txXPat
                             txExecutionState& aEs)
 {
     nsAutoString val;
     txListIterator iter(&mKeys);
     while (iter.hasNext())
     {
         Key* key = (Key*)iter.next();
         if (key->matchPattern->matches(aNode, &aEs)) {
-            txSingleNodeContext evalContext(aNode, &aEs);
-            nsresult rv = aEs.pushEvalContext(&evalContext);
+            txSingleNodeContext *evalContext =
+                new txSingleNodeContext(aNode, &aEs);
+            NS_ENSURE_TRUE(evalContext, NS_ERROR_OUT_OF_MEMORY);
+
+            nsresult rv = aEs.pushEvalContext(evalContext);
             NS_ENSURE_SUCCESS(rv, rv);
 
             nsRefPtr<txAExprResult> exprResult;
-            rv = key->useExpr->evaluate(&evalContext,
+            rv = key->useExpr->evaluate(evalContext,
                                         getter_AddRefs(exprResult));
-            aEs.popEvalContext();
             NS_ENSURE_SUCCESS(rv, rv);
 
+            delete aEs.popEvalContext();
+
             if (exprResult->getResultType() == txAExprResult::NODESET) {
                 txNodeSet* res = NS_STATIC_CAST(txNodeSet*,
                                                 NS_STATIC_CAST(txAExprResult*,
                                                                exprResult));
                 PRInt32 i;
                 for (i = 0; i < res->size(); ++i) {
                     val.Truncate();
                     txXPathNodeUtils::appendNodeValue(res->get(i), val);

