---
 layout/base/nsCSSFrameConstructor.cpp |  182 +++++++++++++---------------------
 layout/tables/nsTableOuterFrame.cpp   |   61 +++++------
 layout/tables/nsTableOuterFrame.h     |    1 
 3 files changed, 107 insertions(+), 137 deletions(-)

Index: mozilla/layout/base/nsCSSFrameConstructor.cpp
===================================================================
--- mozilla.orig/layout/base/nsCSSFrameConstructor.cpp	2007-10-09 15:03:00.000000000 +0200
+++ mozilla/layout/base/nsCSSFrameConstructor.cpp	2007-10-09 15:15:19.000000000 +0200
@@ -3468,23 +3468,38 @@
   NS_PRECONDITION(aFrameItems, "Must have frame items to work with");
 
   aCreatedPseudo = PR_FALSE;
   if (!aParentFrame) {
     // Nothing to do here
     return NS_OK;
   }
 
+  PRBool childIsSpecialContent = PR_FALSE; // lazy lookup
+  // Only use the outer table frame as parent if the child is going to use a
+  // tableCaptionFrame, otherwise the inner table frame is the parent
+  // (bug 341858).
+  if (aParentFrame->GetType() == nsLayoutAtoms::tableOuterFrame) {
+    childIsSpecialContent = IsSpecialContent(aChildContent, aTag, aNameSpaceID,
+                                             aChildStyle);
+    if (childIsSpecialContent ||
+       (aChildStyle->GetStyleDisplay()->mDisplay !=
+       NS_STYLE_DISPLAY_TABLE_CAPTION)) {
+      aParentFrame = aParentFrame->GetContentInsertionFrame();
+    }
+  }
+
   // If our parent is a table, table-row-group, or table-row, and
   // we're not table-related in any way, we have to create table
   // pseudo-frames so that we have a table cell to live in.
   if (IsTableRelated(aParentFrame->GetType(), PR_FALSE) &&
       (!IsTableRelated(aChildDisplay->mDisplay, PR_TRUE) ||
        // Also need to create a pseudo-parent if the child is going to end up
        // with a frame based on something other than display.
+       childIsSpecialContent || // looked it up before
        IsSpecialContent(aChildContent, aTag, aNameSpaceID, aChildStyle))) {
     nsTableCreator tableCreator(aState.mPresShell);
     nsresult rv = GetPseudoCellFrame(tableCreator, aState, *aParentFrame);
     if (NS_FAILED(rv)) {
       return rv;
     }
 
     NS_ASSERTION(aState.mPseudoFrames.mCellInner.mFrame,
@@ -8389,55 +8404,50 @@
 nsCSSFrameConstructor::IsValidSibling(nsIFrame*              aParentFrame,
                                       const nsIFrame&        aSibling,
                                       PRUint8                aSiblingDisplay,
                                       nsIContent&            aContent,
                                       PRUint8&               aDisplay)
 {
   if ((NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == aSiblingDisplay) ||
       (NS_STYLE_DISPLAY_TABLE_COLUMN       == aSiblingDisplay) ||
+      (NS_STYLE_DISPLAY_TABLE_CAPTION      == aSiblingDisplay) ||
       (NS_STYLE_DISPLAY_TABLE_HEADER_GROUP == aSiblingDisplay) ||
       (NS_STYLE_DISPLAY_TABLE_ROW_GROUP    == aSiblingDisplay) ||
       (NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP == aSiblingDisplay)) {
     // if we haven't already, construct a style context to find the display type of aContent
     if (UNSET_DISPLAY == aDisplay) {
       nsRefPtr<nsStyleContext> styleContext;
       styleContext = ResolveStyleContext(aSibling.GetParent(), &aContent);
       if (!styleContext) return PR_FALSE;
       const nsStyleDisplay* display = styleContext->GetStyleDisplay();
       aDisplay = display->mDisplay;
     }
     switch (aSiblingDisplay) {
     case NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP:
       return (NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == aDisplay);
     case NS_STYLE_DISPLAY_TABLE_COLUMN:
       return (NS_STYLE_DISPLAY_TABLE_COLUMN == aDisplay);
+    case NS_STYLE_DISPLAY_TABLE_CAPTION:
+      return (NS_STYLE_DISPLAY_TABLE_CAPTION == aDisplay);
     default: // all of the row group types
       return (NS_STYLE_DISPLAY_TABLE_HEADER_GROUP == aDisplay) ||
              (NS_STYLE_DISPLAY_TABLE_ROW_GROUP    == aDisplay) ||
              (NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP == aDisplay) ||
              (NS_STYLE_DISPLAY_TABLE_CAPTION      == aDisplay);
     }
   }
-  else if (NS_STYLE_DISPLAY_TABLE_CAPTION == aSiblingDisplay) {
-    // Nothing can be a sibling of a caption since there can only be one caption.
-    // But this check is necessary since a row group and caption are siblings
-    // from a content perspective (they share the table content as parent)
-    return PR_FALSE;
-  }
-  else {
-    if (nsLayoutAtoms::fieldSetFrame == aParentFrame->GetType()) {
-      // Legends can be sibling of legends but not of other content in the fieldset
-      nsIAtom* sibType = aSibling.GetType();
-      nsCOMPtr<nsIDOMHTMLLegendElement> legendContent(do_QueryInterface(&aContent));
-
-      if ((legendContent  && (nsLayoutAtoms::legendFrame != sibType)) ||
-          (!legendContent && (nsLayoutAtoms::legendFrame == sibType)))
-        return PR_FALSE;
-    }
+  else if (nsLayoutAtoms::fieldSetFrame == aParentFrame->GetType()) {
+    // Legends can be sibling of legends but not of other content in the fieldset
+    nsIAtom* sibType = aSibling.GetType();
+    nsCOMPtr<nsIDOMHTMLLegendElement> legendContent(do_QueryInterface(&aContent));
+
+    if ((legendContent  && (nsLayoutAtoms::legendFrame != sibType)) ||
+        (!legendContent && (nsLayoutAtoms::legendFrame == sibType)))
+      return PR_FALSE;
   }
 
   return PR_TRUE;
 }
 
 /**
  * Find the ``rightmost'' frame for the content immediately preceding
  * aIndexInContainer, following continuations if necessary.
@@ -8871,46 +8881,28 @@
     RemoveLetterFrames(state.mPresContext, state.mPresShell,
                        state.mFrameManager, containingBlock);
   }
 
   // if the container is a table and a caption was appended, it needs to be put in
   // the outer table frame's additional child list. 
   nsFrameItems captionItems;
   
-  PRBool hasCaption = PR_FALSE;
-  if (nsLayoutAtoms::tableFrame == frameType) {
-    nsIFrame* outerTable = parentFrame->GetParent();
-    if (outerTable) { 
-      if (outerTable->GetFirstChild(nsLayoutAtoms::captionList)) {
-        hasCaption = PR_TRUE;
-      }
-    }  
-  }
   PRUint32 i;
   count = aContainer->GetChildCount();
   for (i = aNewIndexInContainer; i < count; i++) {
     nsIContent *childContent = aContainer->GetChildAt(i);
     // lookup the table child frame type as it is much more difficult to remove a frame
     // and all it descendants (abs. pos. for instance) than to prevent the frame creation.
     if (nsLayoutAtoms::tableFrame == frameType) {
-      if (hasCaption) {
-        // Resolve the style context and get its display
-        nsRefPtr<nsStyleContext> childStyleContext;
-        childStyleContext = ResolveStyleContext(parentFrame, childContent);
-        if (childStyleContext->GetStyleDisplay()->mDisplay == NS_STYLE_DISPLAY_TABLE_CAPTION)
-          continue; //don't create a table caption frame and its descendants
-      }
       nsFrameItems tempItems;
       ConstructFrame(state, childContent, parentFrame, tempItems);
       if (tempItems.childList) {
         if (nsLayoutAtoms::tableCaptionFrame == tempItems.childList->GetType()) {
-          NS_ASSERTION(!captionItems.childList, "don't append twice a caption");
-          hasCaption = PR_TRUE; // remember that we have a caption now
-          captionItems.AddChild(tempItems.childList);        
+          captionItems.AddChild(tempItems.childList);
         }
         else {
           frameItems.AddChild(tempItems.childList);
         }
       }
     }
     else if (nsLayoutAtoms::tableColGroupFrame == frameType) {
       nsRefPtr<nsStyleContext> childStyleContext;
@@ -9117,17 +9109,18 @@
   if (!IsInlineFrame2(aParentFrame)) 
     return PR_FALSE;
 
   // find out if aChild is a block or inline
   PRBool childIsBlock = PR_FALSE;
   if (aChild->IsContentOfType(nsIContent::eELEMENT)) {
     nsRefPtr<nsStyleContext> styleContext;
     styleContext = ResolveStyleContext(aParentFrame, aChild);
-    childIsBlock = styleContext->GetStyleDisplay()->IsBlockLevel();
+    const nsStyleDisplay* display = styleContext->GetStyleDisplay();
+    childIsBlock = display->IsBlockLevel() || IsTableRelated(display->mDisplay, PR_TRUE);
   }
   nsIFrame* prevParent; // parent of prev sibling
   nsIFrame* nextParent; // parent of next sibling
 
   if (childIsBlock) { 
     if (aPrevSibling) {
       prevParent = aPrevSibling->GetParent(); 
       NS_ASSERTION(prevParent, "program error - null parent frame");
@@ -9464,31 +9457,21 @@
     // if we don't need to reframe then set parentFrame and prevSibling to the correct values
     if (NeedSpecialFrameReframe(aContainer, container, parentFrame, 
                                 aChild, aIndexInContainer, prevSibling,
                                 nextSibling)) {
       return ReframeContainingBlock(parentFrame);
     }
   }
 
-  nsFrameItems            frameItems;
   nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
                                 GetAbsoluteContainingBlock(parentFrame),
                                 GetFloatContainingBlock(parentFrame),
                                 aFrameState);
 
-  PRBool hasCaption = PR_FALSE;
-  if (nsLayoutAtoms::tableFrame == parentFrame->GetType()) {
-    nsIFrame* outerTable = parentFrame->GetParent();
-    if (outerTable) {
-      if (outerTable->GetFirstChild(nsLayoutAtoms::captionList)) {
-        hasCaption = PR_TRUE;
-      }
-    }
-  }
 
   // Recover state for the containing block - we need to know if
   // it has :first-letter or :first-line style applied to it. The
   // reason we care is that the internal structure in these cases
   // is not the normal structure and requires custom updating
   // logic.
   nsIFrame* containingBlock = state.mFloatedItems.containingBlock;
   nsStyleContext* blockSC;
@@ -9575,47 +9558,55 @@
     }
   }
   else if (NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == parentDisplay->mDisplay) {
       nsRefPtr<nsStyleContext> childStyleContext;
       childStyleContext = ResolveStyleContext(parentFrame, aChild);
       if (childStyleContext->GetStyleDisplay()->mDisplay != NS_STYLE_DISPLAY_TABLE_COLUMN)
         return NS_OK; //don't create anything else than columns below a colgroup  
   }
-  else if (parentFrame->GetType() == nsLayoutAtoms::tableFrame && hasCaption) {
-    // Resolve the style context and get its display
-    nsRefPtr<nsStyleContext> childStyleContext;
-    childStyleContext = ResolveStyleContext(parentFrame, aChild);
-    if (childStyleContext->GetStyleDisplay()->mDisplay == NS_STYLE_DISPLAY_TABLE_CAPTION)
-      return NS_OK; //don't create a second table caption frame and its descendants
-  }
 
   // if the container is a table and a caption will be appended, it needs to be
   // put in the outer table frame's additional child list.
   
-  nsFrameItems tempItems, captionItems;
+  nsFrameItems frameItems, captionItems;
 
-  ConstructFrame(state, aChild, parentFrame, tempItems);
-  if (tempItems.childList) {
-    if (nsLayoutAtoms::tableCaptionFrame == tempItems.childList->GetType()) {
-      captionItems.AddChild(tempItems.childList);
-    }
-    else {
-      frameItems.AddChild(tempItems.childList);
+  ConstructFrame(state, aChild, parentFrame, frameItems);
+  if (frameItems.childList) {
+    if (nsLayoutAtoms::tableCaptionFrame == frameItems.childList->GetType()) {
+      NS_ASSERTION(frameItems.childList == frameItems.lastChild ,
+                   "adding a non caption frame to the caption childlist?");
+      captionItems.AddChild(frameItems.childList);
+      frameItems = nsFrameItems();
     }
   }
 
   // Now that we've created frames, run the attach queue.
   //XXXwaterson should we do this after we've processed pseudos, too?
   mDocument->BindingManager()->ProcessAttachedQueue();
 
   // process the current pseudo frame state
   if (!state.mPseudoFrames.IsEmpty())
     ProcessPseudoFrames(state, frameItems);
 
+  // If the final parent frame (decided by AdjustParentFrame()) is different
+  // from the parent of the insertion point we calculated above then
+  // parentFrame/prevSibling/appendAfterFrame are now invalid and  as it is
+  // unknown where to insert correctly we append instead (bug 341858).
+  if (frameItems.childList &&
+      frameItems.childList->GetParent() != parentFrame) {
+    prevSibling = nsnull;
+    isAppend = PR_TRUE;
+    parentFrame =
+      ::AdjustAppendParentForAfterContent(mPresShell->GetPresContext(),
+                                         aContainer,
+                                         frameItems.childList->GetParent(),
+                                         &appendAfterFrame);
+  }
+
   // XXX Bug 19949
   // Although select frame are inline we do not want to call
   // WipeContainingBlock because it will throw away the entire select frame and 
   // start over which is something we do not want to do
   //
   nsCOMPtr<nsIDOMHTMLSelectElement> selectContent = do_QueryInterface(aContainer);
   if (!selectContent) {
     // Perform special check for diddling around with the frames in
@@ -9636,16 +9627,17 @@
       // Use more complicated insert logic when inserting
       InsertFirstLineFrames(state, aContainer, containingBlock, &parentFrame,
                             prevSibling, frameItems);
     }
   }
       
   nsIFrame* newFrame = frameItems.childList;
   if (NS_SUCCEEDED(rv) && newFrame) {
+    NS_ASSERTION(!captionItems.childList, "leaking caption frames");
     // Notify the parent frame
     if (isAppend) {
       AppendFrames(state, aContainer, parentFrame, newFrame, appendAfterFrame);
     }
     else {
       if (!prevSibling) {
         // We're inserting the new frame as the first child. See if the
         // parent has a :before pseudo-element
@@ -9674,23 +9666,26 @@
     if (NS_SUCCEEDED(rv) && newCaptionFrame) {
       nsIFrame* outerTableFrame;
       if (GetCaptionAdjustedParent(parentFrame, newCaptionFrame, &outerTableFrame)) {
         // If the parent is not a outer table frame we will try to add frames
         // to a named child list that the parent does not honour and the frames
         // will get lost
         NS_ASSERTION(nsLayoutAtoms::tableOuterFrame == outerTableFrame->GetType(),
                      "Pseudo frame construction failure, a caption can be only a child of a outer table frame");
-        // the double caption creation was prevented above, so we are sure
-        // that we can append
-        NS_ASSERTION(!outerTableFrame->GetFirstChild(nsLayoutAtoms::captionList),
-                     "No double captions please");
-        state.mFrameManager->AppendFrames(outerTableFrame,
-                                          nsLayoutAtoms::captionList,
-                                          newCaptionFrame);
+        if (isAppend) {
+          state.mFrameManager->AppendFrames(outerTableFrame,
+                                            nsLayoutAtoms::captionList,
+                                            newCaptionFrame);
+        }
+        else {
+          state.mFrameManager->InsertFrames(outerTableFrame,
+                                            nsLayoutAtoms::captionList,
+                                            prevSibling, newCaptionFrame);
+        }
       }
     }
   }
   // Here we have been notified that content has been insert
   // so if the select now has a single item 
   // we need to go in and removed the dummy frame
   nsCOMPtr<nsIDOMHTMLSelectElement> selectElement = do_QueryInterface(aContainer);
   if (selectElement)
@@ -11277,57 +11272,28 @@
     // XXXbz should we be passing in a non-null aContentParentFrame?
     nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
 
     // Create a continuing inner table frame, and if there's a caption then
     // replicate the caption
     nsFrameItems  newChildFrames;
 
     nsIFrame* childFrame = aFrame->GetFirstChild(nsnull);
-    while (childFrame) {
-      // See if it's the inner table frame
-      if (nsLayoutAtoms::tableFrame == childFrame->GetType()) {
-        nsIFrame* continuingTableFrame;
-
-        // It's the inner table frame, so create a continuing frame
-        rv = CreateContinuingFrame(aPresContext, childFrame, newFrame,
-                                   &continuingTableFrame);
-        if (NS_FAILED(rv)) {
-          newFrame->Destroy(aPresContext);
-          *aContinuingFrame = nsnull;
-          return rv;
-        }
-        newChildFrames.AddChild(continuingTableFrame);
-      } else {
-        // XXX remove this code and the above checks. We don't want to replicate 
-        // the caption (that is what the thead is for). This code is not executed 
-        // anyway, because the caption was put in a different child list.
-        nsStyleContext*       captionStyle = childFrame->GetStyleContext();
-        nsIContent*           caption = childFrame->GetContent();
-        NS_ASSERTION(NS_STYLE_DISPLAY_TABLE_CAPTION ==
-                       captionStyle->GetStyleDisplay()->mDisplay,
-                     "expected caption");
-
-        // Replicate the caption frame
-        // XXX We have to do it this way instead of calling ConstructFrameByDisplayType(),
-        // because of a bug in the way ConstructTableFrame() handles the initial child
-        // list...
-        nsIFrame*               captionFrame;
-        nsFrameItems            childItems;
-        NS_NewTableCaptionFrame(aPresShell, &captionFrame);
-        nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
-                                      GetAbsoluteContainingBlock(newFrame),
-                                      captionFrame);
-        captionFrame->Init(aPresContext, caption, newFrame, captionStyle, nsnull);
-        ProcessChildren(state, caption, captionFrame, PR_TRUE, childItems,
-                        PR_TRUE);
-        captionFrame->SetInitialChildList(aPresContext, nsnull, childItems.childList);
-        newChildFrames.AddChild(captionFrame);
+    if (childFrame) {
+      nsIFrame* continuingTableFrame;
+      rv = CreateContinuingFrame(aPresContext, childFrame, newFrame,
+                                 &continuingTableFrame);
+      if (NS_FAILED(rv)) {
+        newFrame->Destroy(aPresContext);
+        *aContinuingFrame = nsnull;
+        return rv;
       }
-      childFrame = childFrame->GetNextSibling();
+      newChildFrames.AddChild(continuingTableFrame);
+      
+      NS_ASSERTION(!childFrame->GetNextSibling(),"there can be only one inner table frame");
     }
 
     // Set the outer table's initial child list
     newFrame->SetInitialChildList(aPresContext, nsnull, newChildFrames.childList);
   }
 
   *aContinuingFrame = newFrame;
   return rv;
Index: mozilla/layout/tables/nsTableOuterFrame.cpp
===================================================================
--- mozilla.orig/layout/tables/nsTableOuterFrame.cpp	2007-10-09 15:03:32.000000000 +0200
+++ mozilla/layout/tables/nsTableOuterFrame.cpp	2007-10-09 15:15:27.000000000 +0200
@@ -69,20 +69,17 @@
 
 nsTableCaptionFrame::~nsTableCaptionFrame()
 {
 }
 
 NS_IMETHODIMP
 nsTableOuterFrame::Destroy(nsPresContext* aPresContext)
 {
-  if (mCaptionFrame) {
-    mCaptionFrame->Destroy(aPresContext);
-  }
-
+  mCaptionFrames.DestroyFrames(aPresContext);
   return nsHTMLContainerFrame::Destroy(aPresContext);
 }
 
 nsIAtom*
 nsTableCaptionFrame::GetType() const
 {
   return nsLayoutAtoms::tableCaptionFrame;
 }
@@ -173,17 +170,17 @@
 
   return rv;
 }
 
 nsIFrame*
 nsTableOuterFrame::GetFirstChild(nsIAtom* aListName) const
 {
   if (nsLayoutAtoms::captionList == aListName) {
-    return mCaptionFrame;
+    return mCaptionFrames.FirstChild();
   }
   if (!aListName) {
     return mFrames.FirstChild();
   }
   return nsnull;
 }
 
 nsIAtom*
@@ -197,17 +194,18 @@
 
 NS_IMETHODIMP 
 nsTableOuterFrame::SetInitialChildList(nsPresContext* aPresContext,
                                        nsIAtom*        aListName,
                                        nsIFrame*       aChildList)
 {
   if (nsLayoutAtoms::captionList == aListName) {
     // the frame constructor already checked for table-caption display type
-    mCaptionFrame = aChildList;
+    mCaptionFrames.SetFrames(aChildList);
+    mCaptionFrame  = mCaptionFrames.FirstChild();
   }
   else {
     NS_ASSERTION(!aListName, "wrong childlist");
     NS_ASSERTION(mFrames.IsEmpty(), "Frame leak!");
     mFrames.SetFrames(aChildList);
     mInnerTableFrame = nsnull;
     if (aChildList) {
       if (nsLayoutAtoms::tableFrame == aChildList->GetType()) {
@@ -220,77 +218,82 @@
 }
 
 NS_IMETHODIMP
 nsTableOuterFrame::AppendFrames(nsIAtom*        aListName,
                                 nsIFrame*       aFrameList)
 {
   nsresult rv;
 
-  // We only have two child frames: the inner table and one caption frame.
+  // We only have two child frames: the inner table and a caption frame.
   // The inner frame is provided when we're initialized, and it cannot change
   if (nsLayoutAtoms::captionList == aListName) {
-    NS_PRECONDITION(!mCaptionFrame, "already have a caption frame");
-    // We only support having a single caption frame
-    if (mCaptionFrame || (LengthOf(aFrameList) > 1)) {
-      rv = NS_ERROR_UNEXPECTED;
-    } else {
-      // Insert the caption frame into the child list
-      mCaptionFrame = aFrameList;
-
-      // Reflow the new caption frame. It's already marked dirty, so generate a reflow
-      // command that tells us to reflow our dirty child frames
-      rv = GetPresContext()->
-          PresShell()->AppendReflowCommand(this, eReflowType_ReflowDirty,
+    mCaptionFrames.AppendFrames(this, aFrameList);
+    mCaptionFrame = mCaptionFrames.FirstChild();
+
+    // Reflow the new caption frame. It's already marked dirty, so generate a reflow
+    // command that tells us to reflow our dirty child frames
+    rv = GetPresContext()->
+        PresShell()->AppendReflowCommand(this, eReflowType_ReflowDirty,
                                            nsnull);
-    }
+    
   }
   else {
     NS_PRECONDITION(PR_FALSE, "unexpected child frame type");
     rv = NS_ERROR_UNEXPECTED;
   }
 
   return rv;
 }
 
 NS_IMETHODIMP
 nsTableOuterFrame::InsertFrames(nsIAtom*        aListName,
                                 nsIFrame*       aPrevFrame,
                                 nsIFrame*       aFrameList)
 {
-  NS_PRECONDITION(!aPrevFrame, "invalid previous frame");
-  return AppendFrames(aListName, aFrameList);
+  if (nsLayoutAtoms::captionList == aListName) {
+    mCaptionFrames.InsertFrames(nsnull, aPrevFrame, aFrameList);
+    mCaptionFrame = mCaptionFrames.FirstChild();
+
+    // Reflow the new caption frame. It's already marked dirty, so
+    // just tell the pres shell.
+    return GetPresContext()->
+        PresShell()->AppendReflowCommand(this, eReflowType_ReflowDirty,
+                                           nsnull);
+  }
+  else {
+    NS_PRECONDITION(!aPrevFrame, "invalid previous frame");
+    return AppendFrames(aListName, aFrameList);
+  }
 }
 
 NS_IMETHODIMP
 nsTableOuterFrame::RemoveFrame(nsIAtom*        aListName,
                                nsIFrame*       aOldFrame)
 {
   // We only have two child frames: the inner table and one caption frame.
   // The inner frame can't be removed so this should be the caption
   NS_PRECONDITION(nsLayoutAtoms::captionList == aListName, "can't remove inner frame");
-  NS_PRECONDITION(aOldFrame == mCaptionFrame, "invalid caption frame");
 
   PRUint8 captionSide = GetCaptionSide();
 
   // See if the (top/bottom) caption's minimum width impacted the inner table or there
   // is a left/right caption (that likely impacts the inner table)
   if ((mMinCaptionWidth == mRect.width) || 
       (NS_SIDE_LEFT == captionSide) || (NS_SIDE_RIGHT == captionSide)) {
     // The old caption width had an effect on the inner table width so
     // we're going to need to reflow it. Mark it dirty
     mInnerTableFrame->AddStateBits(NS_FRAME_IS_DIRTY);
   }
 
-  // Remove the caption frame and destroy it
-  if (mCaptionFrame && (mCaptionFrame == aOldFrame)) {
-    mCaptionFrame->Destroy(GetPresContext());
-    mCaptionFrame = nsnull;
-    mMinCaptionWidth = 0;
-  }
+  // Remove the frame and destroy it
+  mCaptionFrames.DestroyFrame(GetPresContext(), aOldFrame);
+  mCaptionFrame = mCaptionFrames.FirstChild();
+  
+  mMinCaptionWidth = 0;
 
   // Generate a reflow command so we get reflowed
   GetPresContext()->PresShell()->AppendReflowCommand(this,
                                                      eReflowType_ReflowDirty,
                                                      nsnull);
 
   return NS_OK;
 }
Index: mozilla/layout/tables/nsTableOuterFrame.h
===================================================================
--- mozilla.orig/layout/tables/nsTableOuterFrame.h	2007-10-09 15:03:47.000000000 +0200
+++ mozilla/layout/tables/nsTableOuterFrame.h	2007-10-09 15:15:29.000000000 +0200
@@ -398,16 +398,17 @@
                         nscoord                  aAvailableWidth,
                         nsMargin&                aMargin,
                         nsMargin&                aMarginNoAuto,
                         nsMargin&                aPadding);
 
 private:
   // used to keep track of this frame's children. They are redundant with mFrames, but more convient
   nsTableFrame* mInnerTableFrame; 
+  nsFrameList   mCaptionFrames;
   nsIFrame*     mCaptionFrame;
 
   // used to track caption max element size 
   PRInt32   mMinCaptionWidth;
   nscoord   mPriorAvailWidth;
 
 #ifdef DEBUG_TABLE_REFLOW_TIMING
 public:
