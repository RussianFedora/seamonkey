---
 content/html/content/src/nsHTMLLabelElement.cpp |   34 +++++++++++++++++++++---
 1 file changed, 30 insertions(+), 4 deletions(-)

Index: mozilla/content/html/content/src/nsHTMLLabelElement.cpp
===================================================================
--- mozilla.orig/content/html/content/src/nsHTMLLabelElement.cpp	2007-10-11 12:50:48.000000000 +0200
+++ mozilla/content/html/content/src/nsHTMLLabelElement.cpp	2007-10-11 12:51:10.000000000 +0200
@@ -46,17 +46,17 @@
 #include "nsIForm.h"
 #include "nsIDOMHTMLDocument.h"
 #include "nsIDOMXULDocument.h"
 #include "nsIDocument.h"
 #include "nsIFormControlFrame.h"
 #include "nsIPresShell.h"
 #include "nsGUIEvent.h"
 #include "nsIEventStateManager.h"
-
+#include "nsIDOMHTMLInputElement.h"
 
 class nsHTMLLabelElement : public nsGenericHTMLFormElement,
                            public nsIDOMHTMLLabelElement
 {
 public:
   nsHTMLLabelElement(nsINodeInfo *aNodeInfo);
   virtual ~nsHTMLLabelElement();
 
@@ -67,16 +67,19 @@
   NS_FORWARD_NSIDOMNODE_NO_CLONENODE(nsGenericHTMLFormElement::)
 
   // nsIDOMElement
   NS_FORWARD_NSIDOMELEMENT(nsGenericHTMLFormElement::)
 
   // nsIDOMHTMLElement
   NS_FORWARD_NSIDOMHTMLELEMENT(nsGenericHTMLFormElement::)
 
+  // nsIDOMNSHTMLElement
+  NS_IMETHOD Focus();
+
   // nsIDOMHTMLLabelElement
   NS_DECL_NSIDOMHTMLLABELELEMENT
 
   // nsIFormControl
   NS_IMETHOD_(PRInt32) GetType() const { return NS_FORM_LABEL; }
   NS_IMETHOD Reset();
   NS_IMETHOD SubmitNamesValues(nsIFormSubmission* aFormSubmission,
                                nsIContent* aSubmitElement);
@@ -103,28 +106,30 @@
   virtual nsresult UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
                              PRBool aNotify);
 
 protected:
   already_AddRefed<nsIContent> GetForContent();
   already_AddRefed<nsIContent> GetFirstFormControl(nsIContent *current);
 
   // XXX It would be nice if we could use an event flag instead.
-  PRBool mHandlingEvent;
+  PRPackedBool mHandlingEvent;
+  PRPackedBool mFocusCalled;
 };
 
 // construction, destruction
 
 
 NS_IMPL_NS_NEW_HTML_ELEMENT(Label)
 
 
 nsHTMLLabelElement::nsHTMLLabelElement(nsINodeInfo *aNodeInfo)
   : nsGenericHTMLFormElement(aNodeInfo),
-    mHandlingEvent(PR_FALSE)
+    mHandlingEvent(PR_FALSE),
+    mFocusCalled(PR_FALSE)
 {
 }
 
 nsHTMLLabelElement::~nsHTMLLabelElement()
 {
 }
 
 // nsISupports 
@@ -268,24 +273,45 @@
         }
         break;
     }
     mHandlingEvent = PR_FALSE;
   }
   return rv;
 }
 
+nsresult
+nsHTMLLabelElement::Focus()
+{
+  PRBool oldFocusCalled = mFocusCalled;
+  mFocusCalled = PR_TRUE;
+  nsresult rv = nsGenericHTMLFormElement::Focus();
+  mFocusCalled = oldFocusCalled;
+  return rv;
+}
+
 void
 nsHTMLLabelElement::SetFocus(nsPresContext* aContext)
 {
   // Since we don't have '-moz-user-focus: normal', the only time
   // |SetFocus| will be called is when the accesskey is activated.
   nsCOMPtr<nsIContent> content = GetForContent();
-  if (content)
+  if (content) {
+    if (mFocusCalled) {
+      // Handle input element in a special way, so that focusing
+      // <input type="file"> doesn't focus the input field but the
+      // 'browse...' button.
+      nsCOMPtr<nsIDOMHTMLInputElement> input = do_QueryInterface(content);
+      if (input) {
+        input->Focus();
+        return;
+      }
+    }
     content->SetFocus(aContext);
+  }
 }
 
 nsresult
 nsHTMLLabelElement::Reset()
 {
   return NS_OK;
 }
 
