--- mozilla/gfx/src/freetype/nsFreeType.h.pango-printing	2006-12-01 16:23:21.000000000 -0500
+++ mozilla/gfx/src/freetype/nsFreeType.h	2006-12-01 16:26:46.000000000 -0500
@@ -52,6 +52,7 @@
 #include FT_CACHE_H
 #include FT_CACHE_IMAGE_H
 #include FT_TRUETYPE_TABLES_H
+#include FT_TYPE1_TABLES_H
 #include "nsIFreeType2.h"
 
 typedef struct FT_FaceRec_*  FT_Face;
@@ -138,6 +139,8 @@
 
 typedef FT_ULong (*FT_Get_First_Char_t)(FT_Face, FT_UInt*);
 typedef FT_ULong (*FT_Get_Next_Char_t)(FT_Face, FT_ULong, FT_UInt*);
+typedef FT_Int   (*FT_Has_PS_Glyph_Names_t)(FT_Face);
+typedef FT_Error (*FT_Get_Glyph_Name_t)(FT_Face, FT_UInt, FT_Pointer, FT_UInt);
 
 class nsFreeTypeFace;
 
@@ -193,11 +196,13 @@
 // #endif
   FT_Get_First_Char_t       nsFT_Get_First_Char;
   FT_Get_Next_Char_t        nsFT_Get_Next_Char;
+  FT_Has_PS_Glyph_Names_t   nsFT_Has_PS_Glyph_Names;
+  FT_Get_Glyph_Name_t       nsFT_Get_Glyph_Name;
 
   // this array needs to be big enough to hold all the function pointers
   // plus one extra for the null at the end
 // #ifdef MOZ_SVG
-  static FtFuncList FtFuncs[24];
+  static FtFuncList FtFuncs[28];
 // #else
 //  static FtFuncList FtFuncs[20];
 // #endif
--- mozilla/gfx/src/freetype/nsFreeType.cpp.pango-printing	2006-12-01 16:23:21.000000000 -0500
+++ mozilla/gfx/src/freetype/nsFreeType.cpp	2006-12-01 16:26:46.000000000 -0500
@@ -123,6 +123,8 @@
 // #endif
   {"FT_Get_First_Char",       NS_FT2_OFFSET(nsFT_Get_First_Char),       PR_FALSE},
   {"FT_Get_Next_Char",        NS_FT2_OFFSET(nsFT_Get_Next_Char),        PR_FALSE},
+  {"FT_Has_PS_Glyph_Names",   NS_FT2_OFFSET(nsFT_Has_PS_Glyph_Names),   PR_FALSE},
+  {"FT_Get_Glyph_Name",       NS_FT2_OFFSET(nsFT_Get_Glyph_Name),       PR_TRUE},
   {nsnull,                    0, 0}
 };
 
@@ -388,6 +390,22 @@
 } 
 
 NS_IMETHODIMP
+nsFreeType2::HasPSGlyphNames(FT_Face face, FT_Int *result)
+{
+  // call the FreeType2 function via the function pointer
+  *result = nsFT_Has_PS_Glyph_Names(face);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsFreeType2::GetGlyphName(FT_Face face, FT_UInt glyph_index, FT_Pointer buffer, FT_UInt buffer_max)
+{
+  // call the FreeType2 function via the function pointer
+  FT_Error error = nsFT_Get_Glyph_Name(face, glyph_index, buffer, buffer_max);
+  return error ? NS_ERROR_FAILURE : NS_OK;
+}
+
+NS_IMETHODIMP
 nsFreeType2::SupportsExtFunc(PRBool *res)
 { 
   *res = gHasExtFunc;
--- mozilla/gfx/src/gtk/nsDeviceContextGTK.cpp.pango-printing	2006-12-01 16:23:10.000000000 -0500
+++ mozilla/gfx/src/gtk/nsDeviceContextGTK.cpp	2006-12-01 16:26:35.000000000 -0500
@@ -576,8 +576,10 @@
     // Create a Postscript device context 
     nsCOMPtr<nsIDeviceContextPS> dcps(do_CreateInstance(kCDeviceContextPS, &rv));
     NS_ASSERTION(NS_SUCCEEDED(rv), "Couldn't create PS Device context.");
-    if (NS_FAILED(rv)) 
+    if (NS_FAILED(rv)) { 
+      fprintf (stderr, "OK, failed here\n");
       return NS_ERROR_GFX_COULD_NOT_LOAD_PRINT_MODULE;
+    }
   
     rv = dcps->SetSpec(aDevice);
     if (NS_FAILED(rv)) 
--- mozilla/gfx/src/gtk/mozilla-decoder.h.pango-printing	2006-12-01 16:23:10.000000000 -0500
+++ mozilla/gfx/src/gtk/mozilla-decoder.h	2006-12-01 16:26:35.000000000 -0500
@@ -39,33 +39,15 @@
 #ifndef _MOZILLA_DECODER_H
 #define _MOZILLA_DECODER_H
 
-#include <pango/pangofc-decoder.h>
+#include <pango/pango-fontmap.h>
 
 G_BEGIN_DECLS
 
-#define MOZILLA_TYPE_DECODER (mozilla_decoder_get_type())
-#define MOZILLA_DECODER(object) (G_TYPE_CHECK_INSTANCE_CAST ((object), MOZILLA_TYPE_DECODER, MozillaDecoder))
-#define MOZILLA_IS_DECODER(object) (G_TYPE_CHECK_INSTANCE_TYPE ((object), MOZILLA_TYPE_DECODER))
-
-typedef struct _MozillaDecoder      MozillaDecoder;
-typedef struct _MozillaDecoderClass MozillaDecoderClass;
-
-#define MOZILLA_DECODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MOZILLA_TYPE_DECODER, MozillaDecoderClass))
-#define MOZILLA_IS_DECODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MOZILLA_TYPE_DECODER))
-#define MOZILLA_DECODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MOZILLA_TYPE_DECODER, MozillaDecoderClass))
-
-struct _MozillaDecoder
-{
-  PangoFcDecoder parent_instance;
-};
-
-struct _MozillaDecoderClass
-{
-  PangoFcDecoderClass parent_class;
-};
+#ifdef PSPANGO
+#define mozilla_decoders_init mozilla_decoders_init_ps
+#endif
 
-GType           mozilla_decoder_get_type (void);
-int             mozilla_decoders_init    (void);
+int             mozilla_decoders_init    (PangoFontMap *fontmap);
 
 G_END_DECLS
 
--- mozilla/gfx/src/gtk/nsFontMetricsUtils.cpp.pango-printing	2006-12-01 16:23:10.000000000 -0500
+++ mozilla/gfx/src/gtk/nsFontMetricsUtils.cpp	2006-12-01 16:26:35.000000000 -0500
@@ -143,11 +143,24 @@
 PRBool
 NS_IsPangoEnabled(void)
 {
-    char *val = PR_GetEnv("MOZ_DISABLE_PANGO");
-    if (val)
-        return FALSE;
+    static PRBool beenHere;
+    static PRBool pangoEnabled;
 
-    return TRUE;
+    if (!beenHere) {
+        beenHere = PR_TRUE;
+
+        char *val = PR_GetEnv("MOZ_DISABLE_PANGO");
+        pangoEnabled = !(val);
+
+        if (pangoEnabled) {
+            nsCOMPtr<nsIPref> prefService = do_GetService(NS_PREF_CONTRACTID);
+            if (prefService)
+                prefService->SetDefaultCharPref("general.useragent.extra.pango",
+                                                "pango-text");
+        }
+    }
+
+    return pangoEnabled;
 }
 
 #endif
--- mozilla/gfx/src/gtk/nsFontMetricsPango.h.pango-printing	2006-12-01 16:23:10.000000000 -0500
+++ mozilla/gfx/src/gtk/nsFontMetricsPango.h	2006-12-01 16:26:35.000000000 -0500
@@ -37,17 +37,53 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
+
 #include "nsIFontMetrics.h"
 #include "nsIFontEnumerator.h"
 #include "nsCRT.h"
 #include "nsIAtom.h"
 #include "nsString.h"
 #include "nsVoidArray.h"
+
+#ifdef PSPANGO
+#include "nsFontMetricsPS.h"
+#else
 #include "nsIFontMetricsGTK.h"
+#endif
 
 #include <pango/pango.h>
 
-class nsFontMetricsPango : public nsIFontMetricsGTK
+#ifdef PSPANGO
+
+#define CONTEXT_ARG_DEF
+#define CONTEXT_ARG_PASS
+#define CONTEXT_ARG_NULL
+#define CONTEXT_AND_SURFACE_ARG_DEF  , nsRenderingContextPS *aContext
+#define CONTEXT_AND_SURFACE_ARG_PASS , aContext
+
+#else
+
+#define CONTEXT_ARG_DEF              , nsRenderingContextGTK *aContext
+#define CONTEXT_ARG_PASS             , aContext
+#define CONTEXT_ARG_NULL             , NULL
+#define CONTEXT_AND_SURFACE_ARG_DEF  , nsRenderingContextGTK *aContext, nsDrawingSurfaceGTK *aSurface
+#define CONTEXT_AND_SURFACE_ARG_PASS , aContext, aSurface
+
+#endif
+
+
+#ifdef PSPANGO
+
+#define nsFontMetricsPango   nsFontMetricsPSPango
+#define PSPANGO_PARENT_CLASS nsFontMetricsPS
+
+#else
+
+#define PSPANGO_PARENT_CLASS nsIFontMetricsGTK
+
+#endif
+
+class nsFontMetricsPango : public PSPANGO_PARENT_CLASS
 {
 public:
     nsFontMetricsPango();
@@ -134,20 +170,30 @@
                                      { aAveCharWidth = mAveCharWidth;
                                        return NS_OK; };
 
-    // nsIFontMetricsGTK (calls from the font rendering layer)
-    virtual nsresult GetWidth(const char* aString, PRUint32 aLength,
-                              nscoord& aWidth,
-                              nsRenderingContextGTK *aContext);
-    virtual nsresult GetWidth(const PRUnichar* aString, PRUint32 aLength,
-                              nscoord& aWidth, PRInt32 *aFontID,
-                              nsRenderingContextGTK *aContext);
+    // nsIFontMetrics (calls from the font rendering layer)
+
+#ifdef PSPANGO
+    NS_IMETHOD  GetStringWidth(const char *String,nscoord &aWidth,nscoord aLength);
+    NS_IMETHOD  GetStringWidth(const PRUnichar *aString,nscoord &aWidth,nscoord aLength);
+#endif
+
+    NS_METHOD        GetWidth(const char* aString, PRUint32 aLength,
+                              nscoord& aWidth
+                              CONTEXT_ARG_DEF);
+    NS_METHOD        GetWidth(const PRUnichar* aString, PRUint32 aLength,
+                              nscoord& aWidth, PRInt32 *aFontID
+                              CONTEXT_ARG_DEF);
 
-    virtual nsresult GetTextDimensions(const PRUnichar* aString,
+    NS_METHOD        GetTextDimensions(const char* aString,
+                                       PRUint32 aLength,
+                                       nsTextDimensions& aDimensions
+                                       CONTEXT_ARG_DEF);
+    NS_METHOD        GetTextDimensions(const PRUnichar* aString,
                                        PRUint32 aLength,
                                        nsTextDimensions& aDimensions, 
-                                       PRInt32* aFontID,
-                                       nsRenderingContextGTK *aContext);
-    virtual nsresult GetTextDimensions(const char*         aString,
+                                       PRInt32* aFontID
+                                       CONTEXT_ARG_DEF);
+    NS_METHOD        GetTextDimensions(const char*         aString,
                                        PRInt32             aLength,
                                        PRInt32             aAvailWidth,
                                        PRInt32*            aBreaks,
@@ -155,9 +201,9 @@
                                        nsTextDimensions&   aDimensions,
                                        PRInt32&            aNumCharsFit,
                                        nsTextDimensions&   aLastWordDimensions,
-                                       PRInt32*            aFontID,
-                                       nsRenderingContextGTK *aContext);
-    virtual nsresult GetTextDimensions(const PRUnichar*    aString,
+                                       PRInt32*            aFontID
+                                       CONTEXT_ARG_DEF);
+    NS_METHOD        GetTextDimensions(const PRUnichar*    aString,
                                        PRInt32             aLength,
                                        PRInt32             aAvailWidth,
                                        PRInt32*            aBreaks,
@@ -165,37 +211,37 @@
                                        nsTextDimensions&   aDimensions,
                                        PRInt32&            aNumCharsFit,
                                        nsTextDimensions&   aLastWordDimensions,
-                                       PRInt32*            aFontID,
-                                       nsRenderingContextGTK *aContext);
+                                       PRInt32*            aFontID
+                                       CONTEXT_ARG_DEF);
 
-    virtual nsresult DrawString(const char *aString, PRUint32 aLength,
+    NS_METHOD        DrawString(const char *aString, PRUint32 aLength,
                                 nscoord aX, nscoord aY,
-                                const nscoord* aSpacing,
-                                nsRenderingContextGTK *aContext,
-                                nsDrawingSurfaceGTK *aSurface);
-    virtual nsresult DrawString(const PRUnichar* aString, PRUint32 aLength,
+                                const nscoord* aSpacing
+                                CONTEXT_AND_SURFACE_ARG_DEF);
+    NS_METHOD        DrawString(const PRUnichar* aString, PRUint32 aLength,
                                 nscoord aX, nscoord aY,
                                 PRInt32 aFontID,
-                                const nscoord* aSpacing,
-                                nsRenderingContextGTK *aContext,
-                                nsDrawingSurfaceGTK *aSurface);
+                                const nscoord* aSpacing
+                                CONTEXT_AND_SURFACE_ARG_DEF);
 
 #ifdef MOZ_MATHML
-    virtual nsresult GetBoundingMetrics(const char *aString, PRUint32 aLength,
-                                        nsBoundingMetrics &aBoundingMetrics,
-                                        nsRenderingContextGTK *aContext);
-    virtual nsresult GetBoundingMetrics(const PRUnichar *aString,
+    NS_METHOD        GetBoundingMetrics(const char *aString, PRUint32 aLength,
+                                        nsBoundingMetrics &aBoundingMetrics
+                                        CONTEXT_ARG_DEF);
+    NS_METHOD        GetBoundingMetrics(const PRUnichar *aString,
                                         PRUint32 aLength,
                                         nsBoundingMetrics &aBoundingMetrics,
-                                        PRInt32 *aFontID,
-                                        nsRenderingContextGTK *aContext);
+                                        PRInt32 *aFontID
+                                        CONTEXT_ARG_DEF);
 #endif /* MOZ_MATHML */
 
+#ifndef PSPANGO
     virtual GdkFont* GetCurrentGDKFont(void);
+#endif
 
-    virtual nsresult SetRightToLeftText(PRBool aIsRTL);
+    NS_METHOD        SetRightToLeftText(PRBool aIsRTL);
 
-    virtual nsresult GetClusterInfo(const PRUnichar *aText,
+    NS_METHOD        GetClusterInfo(const PRUnichar *aText,
                                     PRUint32 aLength,
                                     PRUint8 *aClusterStarts);
 
@@ -203,32 +249,35 @@
                                 PRUint32 aLength,
                                 nsPoint aPt);
 
-    virtual nsresult GetRangeWidth(const PRUnichar *aText,
+    NS_METHOD        GetRangeWidth(const PRUnichar *aText,
                                    PRUint32 aLength,
                                    PRUint32 aStart,
                                    PRUint32 aEnd,
                                    PRUint32 &aWidth);
 
-    virtual nsresult GetRangeWidth(const char *aText,
+    NS_METHOD        GetRangeWidth(const char *aText,
                                    PRUint32 aLength,
                                    PRUint32 aStart,
                                    PRUint32 aEnd,
                                    PRUint32 &aWidth);
 
     // get hints for the font
-    static PRUint32    GetHints     (void);
+#ifndef PSPANGO
+    static
+#endif
+    PRUint32    GetHints     (void);
 
     // drawing surface methods
     static nsresult FamilyExists    (nsIDeviceContext *aDevice,
                                      const nsString &aName);
 
+
 private:
 
     // generic font metrics class bits
     nsCStringArray       mFontList;
     nsAutoVoidArray      mFontIsGeneric;
 
-    nsIDeviceContext    *mDeviceContext;
     nsCOMPtr<nsIAtom>    mLangGroup;
     nsCString           *mGenericFont;
     float                mPointSize;
@@ -243,6 +292,9 @@
     PangoAttrList        *mPangoAttrList;
     PRBool                mIsRTL;
 
+#ifndef PSPANGO
+    nsIDeviceContext    *mDeviceContext; 
+
     // Cached font metrics
     nscoord                  mXHeight;
     nscoord                  mSuperscriptOffset;
@@ -260,8 +312,9 @@
     nscoord                  mMaxDescent;
     nscoord                  mMaxAdvance;
     nscoord                  mSpaceWidth;
-    nscoord                  mPangoSpaceWidth;
     nscoord                  mAveCharWidth;
+#endif
+    nscoord                  mPangoSpaceWidth;
 
     // Private methods
     nsresult RealizeFont(void);
@@ -270,13 +323,14 @@
     static PRBool EnumFontCallback(const nsString &aFamily,
                                    PRBool aIsGeneric, void *aData);
 
-    void     DrawStringSlowly(const gchar *aText,
-                              const PRUnichar *aOrigString,
-                              PRUint32 aLength,
-                              GdkDrawable *aDrawable,
-                              GdkGC *aGC, gint aX, gint aY,
-                              PangoLayoutLine *aLine,
-                              const nscoord *aSpacing);
+    void ApplySpacing(const gchar *aText,
+                      PRUint32 aLength,
+                      PangoLayoutLine *aLine,
+                      const nscoord *aSpacing);
+    void ApplySpacing(const PRUnichar *aText,
+                      PRUint32 aLength,
+                      PangoLayoutLine *aLine,
+                      const nscoord *aSpacing);
 
     nsresult GetTextDimensionsInternal(const gchar*        aString,
                                        PRInt32             aLength,
@@ -285,10 +339,20 @@
                                        PRInt32             aNumBreaks,
                                        nsTextDimensions&   aDimensions,
                                        PRInt32&            aNumCharsFit,
-                                       nsTextDimensions&   aLastWordDimensions,
-                                       nsRenderingContextGTK *aContext);
+                                       nsTextDimensions&   aLastWordDimensions
+                                       CONTEXT_ARG_DEF);
+#ifdef MOZ_MATHML
+    void GetBoundingMetricsInternal(PangoLayout *aLayout,
+                                    nsBoundingMetrics &aBoundingMetrics
+                                    CONTEXT_ARG_DEF);
+#endif /* MOZ_MATHML */
+
+    void FixupSpaceWidths (PangoLayout *aLayout);
 
-    void FixupSpaceWidths (PangoLayout *aLayout, const char *aString);
+    PangoLayout* GetLayout (const PRUnichar* aText,
+                            PRUint32         aLength);
+    PangoLayout* GetLayout (const gchar*     aText,
+                            PRInt32          aLength);
 };
 
 class nsFontEnumeratorPango : public nsIFontEnumerator
--- mozilla/gfx/src/gtk/mozilla-decoder.cpp.pango-printing	2006-12-01 16:23:10.000000000 -0500
+++ mozilla/gfx/src/gtk/mozilla-decoder.cpp	2006-12-01 16:31:12.000000000 -0500
@@ -36,16 +36,13 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
-#define PANGO_ENABLE_BACKEND
-#define PANGO_ENABLE_ENGINE
-
-#include <gdk/gdkpango.h>
-#include "mozilla-decoder.h"
 #include <pango/pangoxft.h>
+#include <pango/pangofc-decoder.h>
 #include <pango/pangofc-fontmap.h>
 #include <pango/pangofc-font.h>
 #include <gdk/gdkx.h>
 
+#include "mozilla-decoder.h"
 #include "nsString.h"
 #include "nsIPersistentProperties2.h"
 #include "nsNetUtil.h"
@@ -52,11 +49,39 @@
 #include "nsICharRepresentable.h"
 #include "nsCompressedCharMap.h"
 
+#ifdef PSPANGO
+#define MozillaDecoder MozillaDecoderPS
+#define MozillaDecoderClass MozillaDecoderPSClass
+#endif
+
+static GType           mozilla_decoder_get_type (void);
+
+#define MOZILLA_TYPE_DECODER (mozilla_decoder_get_type())
+#define MOZILLA_DECODER(object) (G_TYPE_CHECK_INSTANCE_CAST ((object), MOZILLA_TYPE_DECODER, MozillaDecoder))
+#define MOZILLA_IS_DECODER(object) (G_TYPE_CHECK_INSTANCE_TYPE ((object), MOZILLA_TYPE_DECODER))
+
+typedef struct _MozillaDecoder      MozillaDecoder;
+typedef struct _MozillaDecoderClass MozillaDecoderClass;
+
+#define MOZILLA_DECODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MOZILLA_TYPE_DECODER, MozillaDecoderClass))
+#define MOZILLA_IS_DECODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MOZILLA_TYPE_DECODER))
+#define MOZILLA_DECODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MOZILLA_TYPE_DECODER, MozillaDecoderClass))
+
+struct _MozillaDecoder
+{
+  PangoFcDecoder parent_instance;
+};
+
+struct _MozillaDecoderClass
+{
+  PangoFcDecoderClass parent_class;
+};
+
 #undef DEBUG_CUSTOM_ENCODER
 
 G_DEFINE_TYPE (MozillaDecoder, mozilla_decoder, PANGO_TYPE_FC_DECODER)
 
-MozillaDecoder *mozilla_decoder_new      (void);
+static MozillaDecoder *mozilla_decoder_new      (void);
 
 static FcCharSet  *mozilla_decoder_get_charset (PangoFcDecoder *decoder,
                                                 PangoFcFont    *fcfont);
@@ -91,12 +116,12 @@
 GHashTable *cmap_hash = NULL;
 GHashTable *wide_hash = NULL;
 
-void
+static void
 mozilla_decoder_init (MozillaDecoder *decoder)
 {
 }
 
-void
+static void
 mozilla_decoder_class_init (MozillaDecoderClass *klass)
 {
     GObjectClass *object_class = G_OBJECT_CLASS(klass);
@@ -110,14 +135,14 @@
     g_type_class_add_private (object_class, sizeof (MozillaDecoderPrivate));
 }
 
-MozillaDecoder *
+static MozillaDecoder *
 mozilla_decoder_new(void)
 {
     return (MozillaDecoder *)g_object_new(MOZILLA_TYPE_DECODER, NULL);
 }
 
 #ifdef DEBUG_CUSTOM_ENCODER
-void
+static void
 dump_hash(char *key, char *val, void *arg)
 {
     printf("%s -> %s\n", key, val);
@@ -136,21 +161,21 @@
  * Return value: zero on success, not zero on failure.
  *
  **/
-
 int
-mozilla_decoders_init(void)
+mozilla_decoders_init(PangoFontMap *fontmap)
 {
-    static PRBool initialized = PR_FALSE;
-    if (initialized)
-        return 0;
+    static GQuark init_quark;
 
-    PangoContext* context = gdk_pango_context_get ();
-    PangoFontMap* fontmap = pango_context_get_font_map (context);
-    g_object_unref (context);
-    
     if (!PANGO_IS_FC_FONT_MAP (fontmap))
         return -1;
 
+    if (G_UNLIKELY (!init_quark)) {
+      init_quark = g_quark_from_static_string ("mozilla-decoders-set");
+    }
+
+    if (G_LIKELY (g_object_get_qdata ((GObject *)fontmap, init_quark)))
+      return 0;
+
     encoder_hash = g_hash_table_new(g_str_hash, g_str_equal);
     cmap_hash = g_hash_table_new(g_str_hash, g_str_equal);
     wide_hash = g_hash_table_new(g_str_hash, g_str_equal);
@@ -219,7 +244,7 @@
                                             NULL,
                                             NULL);
 
-    initialized = PR_TRUE;
+    g_object_set_qdata ((GObject *)fontmap, init_quark, GINT_TO_POINTER (1));
 
 #ifdef DEBUG_CUSTOM_ENCODER
     printf("*** encoders\n");
@@ -235,7 +260,7 @@
     return -1;
 }
 
-FcCharSet *
+static FcCharSet *
 mozilla_decoder_get_charset (PangoFcDecoder *decoder,
                              PangoFcFont    *fcfont)
 {
@@ -283,7 +308,7 @@
     return priv->charset;
 }
 
-PangoGlyph
+static PangoGlyph
 mozilla_decoder_get_glyph   (PangoFcDecoder *decoder,
                              PangoFcFont    *fcfont,
                              guint32         wc)
@@ -344,7 +369,7 @@
     return retval;
 }
 
-PangoFcDecoder *
+static PangoFcDecoder *
 mozilla_find_decoder (FcPattern *pattern, gpointer user_data)
 {
     // Compare the family name of the font that's been opened to see
--- mozilla/gfx/src/gtk/nsFontMetricsPango.cpp.pango-printing	2006-12-01 16:23:10.000000000 -0500
+++ mozilla/gfx/src/gtk/nsFontMetricsPango.cpp	2006-12-01 16:31:21.000000000 -0500
@@ -21,6 +21,8 @@
  * are Copyright (C) 2004 the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
+ *   Christopher Blizzard <blizzard@mozilla.org>
+ *   Behdad Esfahbod <behdad@behdad.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -36,6 +38,10 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
+#define PANGO_ENABLE_BACKEND
+
+#include "nsFontMetricsPango.h"
+
 #include <strings.h>
 #include "nsFont.h"
 #include "nsIDeviceContext.h"
@@ -43,27 +49,37 @@
 #include "nsIPref.h"
 #include "nsServiceManagerUtils.h"
 
-#define PANGO_ENABLE_BACKEND
-#define PANGO_ENABLE_ENGINE
-
-#include "nsFontMetricsPango.h"
-#include "nsRenderingContextGTK.h"
-#include "nsDeviceContextGTK.h"
 #include "nsFontConfigUtils.h"
 
 #include "nsUnicharUtils.h"
 #include "nsQuickSort.h"
 #include "nsFontConfigUtils.h"
+#include "mozilla-decoder.h"
+
+#define FORCE_PR_LOG
+#include "prlog.h"
+
 
 #include <fontconfig/fontconfig.h>
+#include <freetype/tttables.h>
+
+#include <pango/pango.h>
+#include <pango/pangofc-font.h>
+
+#ifdef PSPANGO
+#include <pango/pangoft2.h>
+#include "nsRenderingContextPS.h"
+#include "nsDeviceContextPS.h"
+#include "nsType1.h"
+#else
 #include <gdk/gdk.h>
 #include <gdk/gdkx.h>
-#include <freetype/tttables.h>
+#include "nsRenderingContextGTK.h"
+#include "nsDeviceContextGTK.h"
+#endif
+
 
-#include "mozilla-decoder.h"
 
-#define FORCE_PR_LOG
-#include "prlog.h"
 
 // Globals
 
@@ -108,6 +124,49 @@
                                      PRUint32* aCount, PRUnichar*** aResult);
 static int         CompareFontNames (const void* aArg1, const void* aArg2,
                                      void* aClosure);
+static void  utf16_to_utf8 (const PRUnichar* aString, PRUint32 aLength,
+                            char *&text, gint &text_len);
+
+#ifdef PSPANGO
+static void
+default_substitute (FcPattern *pattern,
+                    gpointer   data)
+{
+  FcPatternDel (pattern, FC_HINTING);
+  FcPatternAddBool (pattern, FC_HINTING, 0);
+}
+#endif
+
+static PangoFontMap *
+get_fontmap (void)
+{
+  static PangoFontMap               *fontmap = NULL;
+
+  if (!fontmap) {
+#ifdef PSPANGO
+    fontmap = pango_ft2_font_map_new ();
+    pango_ft2_font_map_set_resolution ((PangoFT2FontMap *)fontmap, 72., 72.);
+    pango_ft2_font_map_set_default_substitute ((PangoFT2FontMap *)fontmap, default_substitute, NULL, NULL);
+#else
+    PangoContext* context = gdk_pango_context_get ();
+    fontmap = pango_context_get_font_map (context);
+    g_object_unref (context);
+#endif
+  }
+
+  return fontmap;
+}
+
+static PangoContext *
+get_context (void)
+{
+#ifdef PSPANGO
+  return pango_ft2_font_map_create_context ((PangoFT2FontMap *) get_fontmap ());
+#else
+  return gdk_pango_context_get();
+#endif
+}
+
 
 nsFontMetricsPango::nsFontMetricsPango()
 {
@@ -129,7 +188,7 @@
         return;
 
     // Initialized the custom decoders
-    if (!mozilla_decoders_init())
+    if (!mozilla_decoders_init(get_fontmap ()))
         initialized = PR_TRUE;
 }
 
@@ -169,14 +228,20 @@
     mLangGroup = aLangGroup;
 
     // Hang on to the device context
+#ifdef PSPANGO
+    mDeviceContext = (nsDeviceContextPS *)aContext;
+#else
     mDeviceContext = aContext;
+#endif
     
     mPointSize = NSTwipsToFloatPoints(mFont.size);
 
+#ifndef PSPANGO
     // Make sure to clamp the pixel size to something reasonable so we
     // don't make the X server blow up.
     nscoord screenPixels = gdk_screen_height();
     mPointSize = PR_MIN(screenPixels * FONT_MAX_FONT_SCALE, mPointSize);
+#endif
 
     // enumerate over the font names passed in
     mFont.EnumerateFamilies(nsFontMetricsPango::EnumFontCallback, this);
@@ -325,7 +390,7 @@
 
     // mPangoSpaceWidth
     PangoLayout *layout = pango_layout_new(mPangoContext);
-    pango_layout_set_text(layout, " ", 1);
+    pango_layout_set_text(layout, " ", -1);
     int pswidth, psheight;
     pango_layout_get_size(layout, &pswidth, &psheight);
     mPangoSpaceWidth = pswidth;
@@ -333,14 +398,14 @@
 
     // mSpaceWidth (width of a space)
     nscoord tmpWidth;
-    GetWidth(" ", 1, tmpWidth, NULL);
+    GetWidth(" ", 1, tmpWidth CONTEXT_ARG_NULL);
     mSpaceWidth = tmpWidth;
 
     // mAveCharWidth (width of an 'average' char)
     //    XftTextExtents16(GDK_DISPLAY(), xftFont, &xUnichar, 1, &extents);
     //rawWidth = extents.width;
     //mAveCharWidth = NSToCoordRound(rawWidth * f);
-    GetWidth("x", 1, tmpWidth, NULL);
+    GetWidth("x", 1, tmpWidth CONTEXT_ARG_NULL);
     mAveCharWidth = tmpWidth;
 
     // mXHeight (height of an 'x' character)
@@ -456,130 +521,96 @@
 
 // nsIFontMetricsPango impl
 
-nsresult
-nsFontMetricsPango::GetWidth(const char* aString, PRUint32 aLength,
-                             nscoord& aWidth,
-                             nsRenderingContextGTK *aContext)
+#ifdef PSPANGO
+NS_IMETHODIMP
+nsFontMetricsPSPango::GetStringWidth(const char *String,nscoord &aWidth,nscoord aLength)
 {
-    PangoLayout *layout = pango_layout_new(mPangoContext);
-
-    pango_layout_set_text(layout, aString, aLength);
+    return GetWidth (String, (PRUint32) aLength, aWidth CONTEXT_ARG_NULL);
+}
 
-    if (mPangoSpaceWidth)
-        FixupSpaceWidths(layout, aString);
+NS_IMETHODIMP
+nsFontMetricsPSPango::GetStringWidth(const PRUnichar *aString,nscoord &aWidth,nscoord aLength)
+{
+    return GetWidth (aString, (PRUint32)aLength, aWidth, NULL CONTEXT_ARG_NULL);
+}
+#endif
 
+nsresult
+nsFontMetricsPango::GetWidth(const char* aString, PRUint32 aLength,
+                             nscoord& aWidth
+                             CONTEXT_ARG_DEF)
+{
     int width, height;
-
+    PangoLayout *layout = GetLayout(aString, aLength);
     pango_layout_get_size(layout, &width, &height);
-
     g_object_unref(layout);
 
-    float f;
-    f = mDeviceContext->DevUnitsToAppUnits();
+    float f = mDeviceContext->DevUnitsToAppUnits();
     aWidth = NSToCoordRound(width * f / PANGO_SCALE);
 
-    //    printf("GetWidth (char *) %d\n", aWidth);
-
     return NS_OK;
 }
 
 nsresult
 nsFontMetricsPango::GetWidth(const PRUnichar* aString, PRUint32 aLength,
-                             nscoord& aWidth, PRInt32 *aFontID,
-                             nsRenderingContextGTK *aContext)
+                             nscoord& aWidth, PRInt32 *aFontID
+                             CONTEXT_ARG_DEF)
 {
-    nsresult rv = NS_OK;
-    PangoLayout *layout = pango_layout_new(mPangoContext);
-
-    gchar *text = g_utf16_to_utf8(aString, aLength,
-                                  NULL, NULL, NULL);
-
-    if (!text) {
-        aWidth = 0;
-#ifdef DEBUG
-        NS_WARNING("nsFontMetricsPango::GetWidth invalid unicode to follow");
-        DUMP_PRUNICHAR(aString, aLength)
-#endif
-        rv = NS_ERROR_FAILURE;
-        goto loser;
-    }
-
     gint width, height;
-
-    pango_layout_set_text(layout, text, strlen(text));
-    FixupSpaceWidths(layout, text);
+    PangoLayout *layout = GetLayout(aString, aLength);
     pango_layout_get_size(layout, &width, &height);
+    g_object_unref(layout);
 
-    float f;
-    f = mDeviceContext->DevUnitsToAppUnits();
+    float f = mDeviceContext->DevUnitsToAppUnits();
     aWidth = NSToCoordRound(width * f / PANGO_SCALE);
 
-    //    printf("GetWidth %d\n", aWidth);
-
- loser:
-    g_free(text);
-    g_object_unref(layout);
-
-    return rv;
+    return NS_OK;
 }
 
 
 nsresult
-nsFontMetricsPango::GetTextDimensions(const PRUnichar* aString,
+nsFontMetricsPango::GetTextDimensions(const char* aString,
                                       PRUint32 aLength,
-                                      nsTextDimensions& aDimensions, 
-                                      PRInt32* aFontID,
-                                      nsRenderingContextGTK *aContext)
+                                      nsTextDimensions& aDimensions
+                                      CONTEXT_ARG_DEF)
 {
-    nsresult rv = NS_OK;
-
-    PangoLayout *layout = pango_layout_new(mPangoContext);
+    PangoLayout *layout = GetLayout(aString, aLength);
+    PangoLayoutLine *line = pango_layout_get_line(layout, 0);
 
-    gchar *text = g_utf16_to_utf8(aString, aLength,
-                                  NULL, NULL, NULL);
-
-    if (!text) {
-#ifdef DEBUG
-        NS_WARNING("nsFontMetricsPango::GetTextDimensions invalid unicode to follow");
-        DUMP_PRUNICHAR(aString, aLength)
-#endif
-        aDimensions.width = 0;
-        aDimensions.ascent = 0;
-        aDimensions.descent = 0;
-
-        rv = NS_ERROR_FAILURE;
-        goto loser;
-    }
-        
+    PangoRectangle logical;
+    pango_layout_line_get_extents(line, NULL, &logical);
+    g_object_unref(layout);
 
-    pango_layout_set_text(layout, text, strlen(text));
-    FixupSpaceWidths(layout, text);
+    float P2T = mDeviceContext->DevUnitsToAppUnits();
 
-    // Get the logical extents
-    PangoLayoutLine *line;
-    if (pango_layout_get_line_count(layout) != 1) {
-        printf("Warning: more than one line!\n");
-    }
-    line = pango_layout_get_line(layout, 0);
+    aDimensions.ascent  = NSToCoordRound(PANGO_ASCENT(logical)  * P2T / PANGO_SCALE);
+    aDimensions.descent = NSToCoordRound(PANGO_DESCENT(logical) * P2T / PANGO_SCALE);
+    aDimensions.width   = NSToCoordRound(logical.width          * P2T / PANGO_SCALE);
 
-    PangoRectangle rect;
-    pango_layout_line_get_extents(line, NULL, &rect);
+    return NS_OK;
+}
 
-    float P2T;
-    P2T = mDeviceContext->DevUnitsToAppUnits();
+nsresult
+nsFontMetricsPango::GetTextDimensions(const PRUnichar* aString,
+                                      PRUint32 aLength,
+                                      nsTextDimensions& aDimensions, 
+                                      PRInt32* aFontID
+                                      CONTEXT_ARG_DEF)
+{
+    PangoLayout *layout = GetLayout(aString, aLength);
+    PangoLayoutLine *line = pango_layout_get_line(layout, 0);
 
-    aDimensions.width = NSToCoordRound(rect.width * P2T / PANGO_SCALE);
-    aDimensions.ascent = NSToCoordRound(PANGO_ASCENT(rect) * P2T / PANGO_SCALE);
-    aDimensions.descent = NSToCoordRound(PANGO_DESCENT(rect) * P2T / PANGO_SCALE);
+    PangoRectangle logical;
+    pango_layout_line_get_extents(line, NULL, &logical);
+    g_object_unref(layout);
 
-    //    printf("GetTextDimensions %d %d %d\n", aDimensions.width,
-    //aDimensions.ascent, aDimensions.descent);
+    float P2T = mDeviceContext->DevUnitsToAppUnits();
 
- loser:
-    g_free(text);
-    g_object_unref(layout);
+    aDimensions.ascent  = NSToCoordRound(PANGO_ASCENT(logical)  * P2T / PANGO_SCALE);
+    aDimensions.descent = NSToCoordRound(PANGO_DESCENT(logical) * P2T / PANGO_SCALE);
+    aDimensions.width   = NSToCoordRound(logical.width          * P2T / PANGO_SCALE);
 
-    return rv;
+    return NS_OK;
 }
 
 nsresult
@@ -591,13 +622,13 @@
                                       nsTextDimensions&   aDimensions,
                                       PRInt32&            aNumCharsFit,
                                       nsTextDimensions&   aLastWordDimensions,
-                                      PRInt32*            aFontID,
-                                      nsRenderingContextGTK *aContext)
+                                      PRInt32*            aFontID
+                                      CONTEXT_ARG_DEF)
 {
 
     return GetTextDimensionsInternal(aString, aLength, aAvailWidth, aBreaks,
                                      aNumBreaks, aDimensions, aNumCharsFit,
-                                     aLastWordDimensions, aContext);
+                                     aLastWordDimensions CONTEXT_ARG_PASS);
 
 }
 
@@ -610,8 +641,8 @@
                                       nsTextDimensions&   aDimensions,
                                       PRInt32&            aNumCharsFit,
                                       nsTextDimensions&   aLastWordDimensions,
-                                      PRInt32*            aFontID,
-                                      nsRenderingContextGTK *aContext)
+                                      PRInt32*            aFontID
+                                      CONTEXT_ARG_DEF)
 {
     nsresult rv = NS_OK;
     PRInt32 curBreak = 0;
@@ -619,23 +650,15 @@
 
     PRInt32 *utf8Breaks = new PRInt32[aNumBreaks];
 
-    gchar *text = g_utf16_to_utf8(aString, (PRInt32)aLength,
-                                  NULL, NULL, NULL);
+    gchar* text;
+    gint text_len;
+    utf16_to_utf8 (aString, aLength, text, text_len);
 
     curChar = text;
 
-    if (!text) {
-#ifdef DEBUG
-        NS_WARNING("nsFontMetricsPango::GetWidth invalid unicode to follow");
-        DUMP_PRUNICHAR(aString, (PRUint32)aLength)
-#endif
-        rv = NS_ERROR_FAILURE;
-        goto loser;
-    }
-
     // Covert the utf16 break offsets to utf8 break offsets
     for (PRInt32 curOffset=0; curOffset < aLength;
-         curOffset++, curChar = g_utf8_find_next_char(curChar, NULL)) {
+         curOffset++, curChar = g_utf8_next_char(curChar)) {
         if (aBreaks[curBreak] == curOffset) {
             utf8Breaks[curBreak] = curChar - text;
             curBreak++;
@@ -649,10 +672,10 @@
     utf8Breaks[curBreak] = curChar - text;
 
 #if 0
-    if (strlen(text) != aLength) {
-        printf("Different lengths for utf16 %d and utf8 %d\n", aLength, strlen(text));
+    if (text_len != aLength) {
+        printf("Different lengths for utf16 %d and utf8 %d\n", aLength, text_len);
         DUMP_PRUNICHAR(aString, aLength)
-        DUMP_PRUNICHAR(text, strlen(text))
+        DUMP_PRUNICHAR(text, text_len)
         for (PRInt32 i = 0; i < aNumBreaks; ++i) {
             printf("  break %d utf16 %d utf8 %d\n", i, aBreaks[i], utf8Breaks[i]);
         }
@@ -662,9 +685,9 @@
     // We'll use curBreak to indicate which of the breaks end up being
     // used for the break point for this line.
     curBreak = 0;
-    rv = GetTextDimensionsInternal(text, strlen(text), aAvailWidth, utf8Breaks,
+    rv = GetTextDimensionsInternal(text, text_len, aAvailWidth, utf8Breaks,
                                    aNumBreaks, aDimensions, aNumCharsFit,
-                                   aLastWordDimensions, aContext);
+                                   aLastWordDimensions CONTEXT_ARG_PASS);
 
     // Figure out which of the breaks we ended up using to convert
     // back to utf16 - start from the end.
@@ -677,204 +700,366 @@
         }
     }
 
- loser:
-    if (text)
-        g_free(text);
+    g_free(text);
 
     delete[] utf8Breaks;
 
     return rv;
 }
 
-nsresult
-nsFontMetricsPango::DrawString(const char *aString, PRUint32 aLength,
-                               nscoord aX, nscoord aY,
-                               const nscoord* aSpacing,
-                               nsRenderingContextGTK *aContext,
-                               nsDrawingSurfaceGTK *aSurface)
+#ifdef PSPANGO
+
+typedef struct _nsPSPangoRenderer        nsPSPangoRenderer;
+typedef struct _nsPSPangoRendererClass   nsPSPangoRendererClass;
+
+struct _nsPSPangoRenderer
 {
-    PangoLayout *layout = pango_layout_new(mPangoContext);
+  PangoRenderer parent_instance;
+  nsRenderingContextPS *psContext;
+  nsFontMetricsPSPango *psPangoFontMetrics;
+  float zoom;
+};
 
-    pango_layout_set_text(layout, aString, aLength);
-    FixupSpaceWidths(layout, aString);
+struct _nsPSPangoRendererClass
+{
+  PangoRendererClass parent_class;
+};
 
-    int x = aX;
-    int y = aY;
+#define _PS_TYPE_PANGO_RENDERER            (_ps_pango_renderer_get_type())
+#define _PS_PANGO_RENDERER(object)         (G_TYPE_CHECK_INSTANCE_CAST ((object), _PS_TYPE_PANGO_RENDERER, _nsPSPangoRenderer))
+#define _PS_IS_PANGO_RENDERER(object)      (G_TYPE_CHECK_INSTANCE_TYPE ((object), _PS_TYPE_PANGO_RENDERER))
+#define _PS_PANGO_RENDERER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), _PS_TYPE_PANGO_RENDERER, _nsPSPangoRendererClass))
+#define _PS_IS_PANGO_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), _PS_TYPE_PANGO_RENDERER))
+#define _PS_PANGO_RENDERER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), _PS_TYPE_PANGO_RENDERER, _nsPSPangoRendererClass))
 
-    aContext->GetTranMatrix()->TransformCoord(&x, &y);
+G_DEFINE_TYPE (_nsPSPangoRenderer, _ps_pango_renderer, PANGO_TYPE_RENDERER)
 
-    PangoLayoutLine *line;
-    if (pango_layout_get_line_count(layout) != 1) {
-        printf("Warning: more than one line!\n");
-    }
-    line = pango_layout_get_line(layout, 0);
+static PangoRenderer *
+get_renderer (void)
+{
+  static PangoRenderer               *renderer = NULL;
 
-    aContext->UpdateGC();
-    GdkGC *gc = aContext->GetGC();
+  if (!renderer)
+    renderer = (PangoRenderer *) g_object_new (_PS_TYPE_PANGO_RENDERER, NULL);
 
-    if (aSpacing && *aSpacing) {
-        DrawStringSlowly(aString, NULL, aLength, aSurface->GetDrawable(),
-                         gc, x, y, line, aSpacing);
-    }
-    else {
-        gdk_draw_layout_line(aSurface->GetDrawable(), gc,
-                             x, y,
-                             line);
-    }
+  return renderer;
+}
 
-    g_object_unref(gc);
-    g_object_unref(layout);
+static void
+_ps_pango_renderer_draw_glyphs (PangoRenderer    *renderer,
+				PangoFont        *font,
+				PangoGlyphString *glyphs,
+				int               x,
+				int               y);
 
-    //    printf("DrawString (char *)\n");
+static void
+_ps_pango_renderer_class_init (nsPSPangoRendererClass *klass)
+{
+  PangoRendererClass *renderer_class = PANGO_RENDERER_CLASS (klass);
+  
+  renderer_class->draw_glyphs = _ps_pango_renderer_draw_glyphs;
+}
 
-    return NS_OK;
+static void
+_ps_pango_renderer_init (nsPSPangoRenderer *renderer)
+{
+}
+
+class nsPangoType1Generator : public nsPSFontGenerator {
+public:
+  nsPangoType1Generator();
+  ~nsPangoType1Generator();
+  nsresult Init(PangoFont *aFont);
+  void  GeneratePSFont(FILE* aFile);
+
+protected:
+  PangoFont *mFont;
+};
+
+nsPangoType1Generator::nsPangoType1Generator()
+{
 }
 
 nsresult
-nsFontMetricsPango::DrawString(const PRUnichar* aString, PRUint32 aLength,
-                               nscoord aX, nscoord aY,
-                               PRInt32 aFontID,
-                               const nscoord* aSpacing,
-                               nsRenderingContextGTK *aContext,
-                               nsDrawingSurfaceGTK *aSurface)
+nsPangoType1Generator::Init(PangoFont *aFont)
 {
-    nsresult rv = NS_OK;
-    int x = aX;
-    int y = aY;
+  NS_ENSURE_TRUE(aFont, NS_ERROR_FAILURE);
+  mFont = aFont;
+  g_object_ref (mFont);
+  return NS_OK;
+}
 
-    aContext->UpdateGC();
-    GdkGC *gc = aContext->GetGC();
+nsPangoType1Generator::~nsPangoType1Generator()
+{
+  g_object_unref (mFont);
+  mFont = nsnull;
+}
 
-    PangoLayout *layout = pango_layout_new(mPangoContext);
+void nsPangoType1Generator::GeneratePSFont(FILE* aFile)
+{
+  FT_Face face = pango_fc_font_lock_face ((PangoFcFont *) mFont);
 
-    gchar *text = g_utf16_to_utf8(aString, aLength,
-                                  NULL, NULL, NULL);
+  if (face == nsnull)
+    return;
 
-    if (!text) {
-#ifdef DEBUG
-        NS_WARNING("nsFontMetricsPango::DrawString invalid unicode to follow");
-        DUMP_PRUNICHAR(aString, aLength)
-#endif
-        rv = NS_ERROR_FAILURE;
-        goto loser;
-    }
+  int wmode = 0;
+  if (mGlyphSubset->Count())
+    FT2SubsetToType1FontSet(face, mGlyphSubset, wmode, aFile);
 
-    pango_layout_set_text(layout, text, strlen(text));
-    FixupSpaceWidths(layout, text);
+  pango_fc_font_unlock_face ((PangoFcFont *) mFont);
+}
 
-    aContext->GetTranMatrix()->TransformCoord(&x, &y);
+typedef struct
+{
+  nsCString    *FontNameBase;
+  nsCStringKey *key;
+  int           font_size;
+} PSPangoFontData;
 
-    PangoLayoutLine *line;
-    if (pango_layout_get_line_count(layout) != 1) {
-        printf("Warning: more than one line!\n");
-    }
-    line = pango_layout_get_line(layout, 0);
+static void
+ps_pango_font_data_destroy (PSPangoFontData *data)
+{
+  delete data->key;
+  delete data->FontNameBase;
+  g_free (data);
+}
 
-    if (aSpacing && *aSpacing) {
-        DrawStringSlowly(text, aString, aLength, aSurface->GetDrawable(),
-                         gc, x, y, line, aSpacing);
-    }
-    else {
-        gdk_draw_layout_line(aSurface->GetDrawable(), gc,
-                             x, y,
-                             line);
+static void
+_ps_pango_renderer_draw_glyphs (PangoRenderer    *renderer,
+				PangoFont        *font,
+				PangoGlyphString *glyphs,
+				int               x,
+				int               y)
+{
+  if (!glyphs->num_glyphs)
+    return;
+
+  static GQuark data_quark = 0;
+  if (!data_quark)
+    data_quark = g_quark_from_static_string ("ps-pango-font-data");
+
+  PSPangoFontData *data;
+  if (!(data = (PSPangoFontData *) g_object_get_qdata (G_OBJECT (font), data_quark)))
+    {
+      data = g_new (PSPangoFontData, 1);
+
+      FT_Face face = pango_fc_font_lock_face ((PangoFcFont *) font);
+      if (face == nsnull)
+        return;
+      int wmode = 0;
+      data->FontNameBase = new nsCString ();
+      if (NS_FAILED(FT2ToType1FontName(face, wmode, *data->FontNameBase))) {
+        g_free (data);
+        pango_fc_font_unlock_face ((PangoFcFont *) font);
+        return;
+      }
+      pango_fc_font_unlock_face ((PangoFcFont *) font);
+
+      PangoFontDescription *desc = pango_font_describe (font);
+      data->font_size = pango_font_description_get_size (desc);
+      pango_font_description_free (desc);
+
+      data->key = new nsCStringKey (*data->FontNameBase);
+
+      g_object_set_qdata_full (G_OBJECT (font), data_quark, data, (GDestroyNotify) ps_pango_font_data_destroy);
+    }
+
+  nsPSPangoRenderer *ps_renderer = (nsPSPangoRenderer *)renderer;
+  nsRenderingContextPS *aContext = ps_renderer->psContext;
+  nsFontMetricsPSPango *metrics = ps_renderer->psPangoFontMetrics;
+  nsDeviceContextPS* dc = NS_REINTERPRET_CAST (nsDeviceContextPS*, metrics->GetDeviceContext());
+  nsPostScriptObj* psObj = aContext->GetPostScriptObj();
+  nsHashtable *psFGList = dc->GetPSFontGeneratorList();
+  g_return_if_fail (psFGList);
+  nsPSFontGenerator* psFontGen = (nsPSFontGenerator*) psFGList->Get(data->key);
+  if (!psFontGen) {
+    nsresult rv;
+    psFontGen = new nsPangoType1Generator;
+    g_return_if_fail (psFontGen);
+    rv = ((nsPangoType1Generator*)psFontGen)->Init(font);
+    if (NS_FAILED(rv)) {
+      delete psFontGen;
+      return;
+    }
+    psFGList->Put(data->key, (void *) psFontGen);
+  }
+  nscoord font_size = NSToCoordRound (ps_renderer->zoom * data->font_size / PANGO_SCALE);
+
+  g_return_if_fail (aContext);
+  g_return_if_fail (psObj);
+
+  nscoord aX = NSToCoordRound(ps_renderer->zoom * x / PANGO_SCALE);
+  nscoord aY = NSToCoordRound(ps_renderer->zoom * y / PANGO_SCALE);
+  psObj->moveto(aX, aY);
+
+  PRInt32 currSubFont, prevSubFont = -1;
+  PRUint32 i;
+  PangoGlyphString gl;
+
+  gl.glyphs = glyphs->glyphs;
+  gl.num_glyphs = 0;
+  currSubFont = prevSubFont;
+  for (i = 0; i < glyphs->num_glyphs; ++i) {
+    PangoGlyph glyph = glyphs->glyphs[i].glyph;
+
+    if (glyph != PANGO_GLYPH_EMPTY)
+      currSubFont = psFontGen->AddToGlyphSubset(glyph > 0x0fffffff ? 0 : glyph);
+
+    if (prevSubFont != currSubFont) {
+      if (prevSubFont != -1)
+        psObj->show(&gl, ps_renderer->zoom,  psFontGen, prevSubFont);
+
+      psObj->setfont(*data->FontNameBase, (PRUint32) font_size, currSubFont);
+      prevSubFont = currSubFont;
+      gl.glyphs = glyphs->glyphs + i;
+      gl.num_glyphs = 0;
     }
 
- loser:
+    gl.num_glyphs++;
+  }
 
-    g_free(text);
-    g_object_unref(gc);
-    g_object_unref(layout);
+  if (prevSubFont != -1)
+    psObj->show(&gl, ps_renderer->zoom, psFontGen, prevSubFont);
+}
 
-    //    printf("DrawString\n");
+#endif
 
-    return rv;
+static void
+draw_layout_line (int x, int y,
+                  PangoLayoutLine *line,
+                  nsFontMetricsPango *fm
+                  CONTEXT_AND_SURFACE_ARG_DEF)
+{
+#ifdef PSPANGO
+  PangoRenderer *renderer = get_renderer ();
+  nsPSPangoRenderer *ps_renderer = (nsPSPangoRenderer *)renderer;
+  ps_renderer->psContext = aContext;
+  ps_renderer->psPangoFontMetrics = fm;
+  nsDeviceContextPS* dc = NS_REINTERPRET_CAST (nsDeviceContextPS*, fm->GetDeviceContext());
+  ps_renderer->zoom = dc->DevUnitsToAppUnits();
+
+  pango_renderer_draw_layout_line (renderer, line,
+                                   NSToCoordRound (x * PANGO_SCALE / ps_renderer->zoom),
+                                   NSToCoordRound (y * PANGO_SCALE / ps_renderer->zoom));
+#else
+    aContext->UpdateGC();
+    GdkGC *gc = aContext->GetGC();
+    gdk_draw_layout_line(aSurface->GetDrawable(), gc, x, y, line);
+    g_object_unref(gc);
+#endif
 }
 
-#ifdef MOZ_MATHML
+
 nsresult
-nsFontMetricsPango::GetBoundingMetrics(const char *aString, PRUint32 aLength,
-                                       nsBoundingMetrics &aBoundingMetrics,
-                                       nsRenderingContextGTK *aContext)
+nsFontMetricsPango::DrawString(const char *aString, PRUint32 aLength,
+                               nscoord aX, nscoord aY,
+                               const nscoord* aSpacing
+                               CONTEXT_AND_SURFACE_ARG_DEF)
 {
-    printf("GetBoundingMetrics (char *)\n");
-    return NS_ERROR_FAILURE;
+    int x = aX;
+    int y = aY;
+
+    aContext->GetTranMatrix()->TransformCoord(&x, &y);
+
+    PangoLayout *layout = GetLayout(aString, aLength);
+    PangoLayoutLine *line = pango_layout_get_line(layout, 0);
+
+    ApplySpacing(aString, aLength, line, aSpacing);
+    draw_layout_line(x, y, line, this CONTEXT_AND_SURFACE_ARG_PASS);
+
+    g_object_unref(layout);
+
+    return NS_OK;
 }
 
 nsresult
-nsFontMetricsPango::GetBoundingMetrics(const PRUnichar *aString,
-                                       PRUint32 aLength,
-                                       nsBoundingMetrics &aBoundingMetrics,
-                                       PRInt32 *aFontID,
-                                       nsRenderingContextGTK *aContext)
+nsFontMetricsPango::DrawString(const PRUnichar* aString, PRUint32 aLength,
+                               nscoord aX, nscoord aY,
+                               PRInt32 aFontID,
+                               const nscoord* aSpacing
+                               CONTEXT_AND_SURFACE_ARG_DEF)
 {
-    nsresult rv = NS_OK;
-    PangoLayout *layout = pango_layout_new(mPangoContext);
+    int x = aX;
+    int y = aY;
 
-    gchar *text = g_utf16_to_utf8(aString, aLength,
-                                  NULL, NULL, NULL);
+    aContext->GetTranMatrix()->TransformCoord(&x, &y);
 
-    if (!text) {
-#ifdef DEBUG
-        NS_WARNING("nsFontMetricsPango::GetBoundingMetrics invalid unicode to follow");
-        DUMP_PRUNICHAR(aString, aLength)
-#endif
-        aBoundingMetrics.leftBearing = 0;
-        aBoundingMetrics.rightBearing = 0;
-        aBoundingMetrics.width = 0;
-        aBoundingMetrics.ascent = 0;
-        aBoundingMetrics.descent = 0;
+    PangoLayout *layout = GetLayout(aString, aLength);
+    PangoLayoutLine *line = pango_layout_get_line(layout, 0);
 
-        rv = NS_ERROR_FAILURE;
-        goto loser;
-    }
+    ApplySpacing(aString, aLength, line, aSpacing);
+    draw_layout_line(x, y, line, this CONTEXT_AND_SURFACE_ARG_PASS);
 
-    pango_layout_set_text(layout, text, -1);
-    FixupSpaceWidths(layout, text);
+    g_object_unref(layout);
 
-    PangoLayoutLine *line;
-    if (pango_layout_get_line_count(layout) != 1) {
-        printf("Warning: more than one line!\n");
-    }
-    line = pango_layout_get_line(layout, 0);
+    return NS_OK;
+}
+
+#ifdef MOZ_MATHML
+void
+nsFontMetricsPango::GetBoundingMetricsInternal(PangoLayout *aLayout,
+                                               nsBoundingMetrics &aBoundingMetrics
+                                               CONTEXT_ARG_DEF)
+{
+    PangoLayoutLine *line = pango_layout_get_line(aLayout, 0);
 
     // Get the ink and logical extents
     PangoRectangle ink, logical;
     pango_layout_line_get_extents(line, &ink, &logical);
 
-    float P2T;
-    P2T = mDeviceContext->DevUnitsToAppUnits();
+    float P2T = mDeviceContext->DevUnitsToAppUnits();
 
     aBoundingMetrics.leftBearing  = NSToCoordRound(PANGO_LBEARING(ink) * P2T / PANGO_SCALE);
     aBoundingMetrics.rightBearing = NSToCoordRound(PANGO_RBEARING(ink) * P2T / PANGO_SCALE);
     aBoundingMetrics.ascent       = NSToCoordRound(PANGO_ASCENT(ink)   * P2T / PANGO_SCALE);
     aBoundingMetrics.descent      = NSToCoordRound(PANGO_DESCENT(ink)  * P2T / PANGO_SCALE);
     aBoundingMetrics.width        = NSToCoordRound(logical.width       * P2T / PANGO_SCALE);
+}
 
- loser:
-    g_free(text);
+
+nsresult
+nsFontMetricsPango::GetBoundingMetrics(const char *aString, PRUint32 aLength,
+                                       nsBoundingMetrics &aBoundingMetrics
+                                       CONTEXT_ARG_DEF)
+{
+    PangoLayout *layout = GetLayout(aString, aLength);
+    GetBoundingMetricsInternal (layout, aBoundingMetrics CONTEXT_ARG_PASS);
     g_object_unref(layout);
 
-    return rv;
+    return NS_OK;
+}
+
+nsresult
+nsFontMetricsPango::GetBoundingMetrics(const PRUnichar *aString,
+                                       PRUint32 aLength,
+                                       nsBoundingMetrics &aBoundingMetrics,
+                                       PRInt32 *aFontID
+                                       CONTEXT_ARG_DEF)
+{
+    PangoLayout *layout = GetLayout(aString, aLength);
+    GetBoundingMetricsInternal (layout, aBoundingMetrics CONTEXT_ARG_PASS);
+    g_object_unref(layout);
+
+    return NS_OK;
 }
 
 #endif /* MOZ_MATHML */
 
+#ifndef PSPANGO
 GdkFont*
 nsFontMetricsPango::GetCurrentGDKFont(void)
 {
     return nsnull;
 }
+#endif
 
 nsresult
 nsFontMetricsPango::SetRightToLeftText(PRBool aIsRTL)
 {
     if (aIsRTL) {
         if (!mRTLPangoContext) {
-            mRTLPangoContext = gdk_pango_context_get();
+            mRTLPangoContext = get_context();
             pango_context_set_base_dir(mRTLPangoContext, PANGO_DIRECTION_RTL);
-
-            gdk_pango_context_set_colormap(mRTLPangoContext, gdk_rgb_get_cmap());
             pango_context_set_language(mRTLPangoContext, GetPangoLanguage(mLangGroup));
             pango_context_set_font_description(mRTLPangoContext, mPangoFontDesc);
         }
@@ -893,34 +1078,18 @@
                                    PRUint32 aLength,
                                    PRUint8 *aClusterStarts)
 {
-    nsresult rv = NS_OK;
     PangoLogAttr *attrs = NULL;
     gint n_attrs = 0;
-    PangoLayout *layout = pango_layout_new(mPangoContext);
-    
-    // Convert the incoming UTF-16 to UTF-8
-    gchar *text = g_utf16_to_utf8(aText, aLength, NULL, NULL, NULL);
-
-    if (!text) {
-#ifdef DEBUG
-        NS_WARNING("nsFontMetricsPango::GetWidth invalid unicode to follow");
-        DUMP_PRUNICHAR(aText, aLength)
-#endif
-        rv = NS_ERROR_FAILURE;
-        goto loser;
-    }
 
-    // Set up the pango layout
-    pango_layout_set_text(layout, text, strlen(text));
-    FixupSpaceWidths(layout, text);
+    PangoLayout *layout = GetLayout(aText, aLength);
+    pango_layout_get_log_attrs(layout, &attrs, &n_attrs);
+    g_object_unref(layout);
 
     // Convert back to UTF-16 while filling in the cluster info
     // structure.
-    pango_layout_get_log_attrs(layout, &attrs, &n_attrs);
-
     for (PRUint32 pos = 0; pos < aLength; pos++) {
         if (IS_HIGH_SURROGATE(aText[pos])) {
-            aClusterStarts[pos] = 1;
+            aClusterStarts[pos] = 1;//FIXME: shouldn't this be zero?! --be
             pos++;
         }
         else {
@@ -928,56 +1097,34 @@
         }
     }
 
- loser:
-    if (attrs)
-        g_free(attrs);
-    if (text)
-        g_free(text);
-    if (layout)
-        g_object_unref(layout);
+    g_free(attrs);
 
-    return rv;
+    return NS_OK;
 }
 
 PRInt32
-nsFontMetricsPango::GetPosition(const PRUnichar *aText, PRUint32 aLength,
-                                nsPoint aPt)
+nsFontMetricsPango::GetPosition(const PRUnichar *aText, PRUint32 aLength, nsPoint aPt)
 {
     int trailing = 0;
     int inx = 0;
-    const gchar *curChar;
     PRInt32 retval = 0;
 
     float f = mDeviceContext->AppUnitsToDevUnits();
     
-    PangoLayout *layout = pango_layout_new(mPangoContext);
     PRUint32 localX = (PRUint32)(aPt.x * PANGO_SCALE * f);
     PRUint32 localY = (PRUint32)(aPt.y * PANGO_SCALE * f);
 
-    // Convert the incoming UTF-16 to UTF-8
-    gchar *text = g_utf16_to_utf8(aText, aLength, NULL, NULL, NULL);
-
-    if (!text) {
-#ifdef DEBUG
-        NS_WARNING("nsFontMetricsPango::GetWidth invalid unicode to follow");
-        DUMP_PRUNICHAR(aText, aLength)
-#endif
-        retval = -1;
-        goto loser;
-    }
-
-    // Set up the pango layout
-    pango_layout_set_text(layout, text, strlen(text));
-    FixupSpaceWidths(layout, text);
+    PangoLayout *layout = GetLayout(aText, aLength);
     
     pango_layout_xy_to_index(layout, localX, localY,
                              &inx, &trailing);
 
     // Convert the index back to the utf-16 index
-    curChar = text;
+    const gchar *text = pango_layout_get_text (layout);
+    const gchar *curChar = text;
 
     for (PRUint32 curOffset=0; curOffset < aLength;
-         curOffset++, curChar = g_utf8_find_next_char(curChar, NULL)) {
+         curOffset++, curChar = g_utf8_next_char(curChar)) {
 
         // Check for a match before checking for a surrogate pair
         if (curChar - text == inx) {
@@ -1000,13 +1147,9 @@
         trailing--;
     }
 
- loser:
-    if (text)
-        g_free(text);
-    if (layout)
-        g_object_unref(layout);
+    g_object_unref(layout);
 
-    return retval;
+    return retval; 
 }
 
 nsresult
@@ -1016,28 +1159,21 @@
                                   PRUint32 aEnd,
                                   PRUint32 &aWidth)
 {
-    nsresult rv = NS_OK;
     PRUint32 utf8Start = 0;
     PRUint32 utf8End = 0;
 
     aWidth = 0;
 
     // Convert the incoming UTF-16 to UTF-8
-    gchar *text = g_utf16_to_utf8(aText, aLength, NULL, NULL, NULL);
-    gchar *curChar = text;
 
-    if (!text) {
-#ifdef DEBUG
-        NS_WARNING("nsFontMetricsPango::GetWidth invalid unicode to follow");
-        DUMP_PRUNICHAR(aText, aLength)
-#endif
-        rv = NS_ERROR_FAILURE;
-        goto loser;
-    }
+    gchar* text;
+    gint text_len;
+    utf16_to_utf8 (aText, aLength, text, text_len);
+    gchar *curChar = text;
 
     // Convert the utf16 offsets into utf8 offsets
     for (PRUint32 curOffset = 0; curOffset < aLength;
-         curOffset++, curChar = g_utf8_find_next_char(curChar, NULL)) {
+         curOffset++, curChar = g_utf8_next_char(curChar)) {
 
         if (curOffset == aStart)
             utf8Start = curChar - text;
@@ -1051,15 +1187,13 @@
 
     // Special case where the end index is the same as the length
     if (aLength == aEnd)
-        utf8End = strlen(text);
+        utf8End = text_len;
 
-    rv = GetRangeWidth(text, strlen(text), utf8Start, utf8End, aWidth);
+    GetRangeWidth(text, text_len, utf8Start, utf8End, aWidth);
 
- loser:
-    if (text)
-        g_free(text);
+    g_free(text);
 
-    return rv;
+    return NS_OK;
 }
 
 nsresult
@@ -1069,43 +1203,26 @@
                                   PRUint32 aEnd,
                                   PRUint32 &aWidth)
 {
-    nsresult rv = NS_OK;
     int *ranges = NULL;
     int n_ranges = 0;
     float f;
 
     aWidth = 0;
 
-    PangoLayout *layout = pango_layout_new(mPangoContext);
-
-    if (!aText) {
-        rv = NS_ERROR_FAILURE;
-        goto loser;
-    }
-
-    pango_layout_set_text(layout, aText, aLength);
-    FixupSpaceWidths(layout, aText);
-
-    PangoLayoutLine *line;
-    if (pango_layout_get_line_count(layout) != 1) {
-        printf("Warning: more than one line!\n");
-    }
-    line = pango_layout_get_line(layout, 0);
+    PangoLayout *layout = GetLayout(aText, aLength);
+    PangoLayoutLine *line = pango_layout_get_line(layout, 0);
 
     pango_layout_line_get_x_ranges(line, aStart, aEnd, &ranges, &n_ranges);
 
     aWidth = (ranges[((n_ranges - 1) * 2) + 1] - ranges[0]);
 
     f = mDeviceContext-> DevUnitsToAppUnits();
-    aWidth = nscoord(aWidth * f / PANGO_SCALE);
+    aWidth = NSToCoordRound(aWidth * f / PANGO_SCALE);
 
- loser:
-    if (ranges)
-        g_free(ranges);
-    if (layout)
-        g_object_unref(layout);
+    g_free(ranges);
+    g_object_unref(layout);
 
-    return rv;
+    return NS_OK;
 }
 
 /* static */
@@ -1128,7 +1245,7 @@
     NS_ConvertUTF16toUTF8 name(aName);
 
     nsresult rv = NS_ERROR_FAILURE;
-    PangoContext *context = gdk_pango_context_get();
+    PangoContext *context = get_context();
     PangoFontFamily **familyList;
     int n;
 
@@ -1227,16 +1344,13 @@
 
     // Now that we have the font description set up, create the
     // context.
-    mLTRPangoContext = gdk_pango_context_get();
+    mLTRPangoContext = get_context();
     mPangoContext = mLTRPangoContext;
 
     // Make sure to set the base direction to LTR - if layout needs to
     // render RTL text it will use ::SetRightToLeftText()
     pango_context_set_base_dir(mPangoContext, PANGO_DIRECTION_LTR);
 
-    // Set the color map so we can draw later.
-    gdk_pango_context_set_colormap(mPangoContext, gdk_rgb_get_cmap());
-
     // Set the pango language now that we have a context
     pango_context_set_language(mPangoContext, GetPangoLanguage(mLangGroup));
 
@@ -1274,79 +1388,268 @@
  * This is only used when there's per-character spacing happening.
  * Well, really it can be either line or character spacing but it's
  * just turtles all the way down!
+ *
+ * To do it correctly (ligatures, etc) we need machinery that is private
+ * in Pango.  IMPORT IT:
+ */
+
+#define _PangoGlyphItemIter _nsFontMetricsPangoGlyphItemIter
+#define PangoGlyphItemIter nsFontMetricsPangoGlyphItemIter
+
+#define LTR(glyph_item) (((glyph_item)->item->analysis.level % 2) == 0)
+
+/* Structure holding state when we're iterating over a GlyphItem.
+ * start_index/cluster_end (and range_start/range_end in
+ * apply_attrs()) are offsets into the text, so note the difference
+ * of glyph_item->item->offset between them and clusters in the
+ * log_clusters[] array.
  */
+typedef struct _PangoGlyphItemIter PangoGlyphItemIter;
+
+struct _PangoGlyphItemIter
+{
+  PangoGlyphItem *glyph_item;
+  const gchar *text;
+  
+  int start_glyph;
+  int start_index;
+  int start_char;
+
+  int end_glyph;
+  int end_index;
+  int end_char;
+};
+
+/**
+ * _pango_glyph_item_iter_next_cluster:
+ * @iter: a #PangoGlyphItemIter
+ * 
+ * Advances the iterator to the next cluster in the glyph item.
+ * 
+ * Return value: %TRUE if the iterator was advanced, %FALSE if we were already on the
+ *  last cluster.
+ **/
+static gboolean
+_pango_glyph_item_iter_next_cluster (PangoGlyphItemIter *iter)
+{
+  int glyph_index = iter->end_glyph;
+  PangoGlyphString *glyphs = iter->glyph_item->glyphs;
+  PangoItem *item = iter->glyph_item->item;
+
+  if (LTR (iter->glyph_item))
+    {
+      if (glyph_index == glyphs->num_glyphs)
+	return FALSE;
+    }
+  else
+    {
+      if (glyph_index < 0)
+	return FALSE;
+    }
+      
+  iter->start_glyph = iter->end_glyph;
+  iter->start_index = iter->end_index;
+  iter->start_char = iter->end_char;
+  
+  if (LTR (iter->glyph_item))
+    {
+      while (TRUE)
+	{
+	  glyph_index++;
+	  
+	  if (glyph_index == glyphs->num_glyphs)
+	    {
+	      iter->end_index = item->offset + item->length;
+	      iter->end_char = item->num_chars;
+	      break;
+	    }
+	  
+	  if (item->offset + glyphs->log_clusters[glyph_index] != iter->start_index)
+	    {
+	      iter->end_index = item->offset + glyphs->log_clusters[glyph_index];
+	      iter->end_char += g_utf8_strlen (iter->text + iter->start_index,
+					       iter->end_index - iter->start_index);
+	      break; 
+	    }
+	}
+    }
+  else			/* RTL */
+    {
+      while (TRUE)
+	{
+	  glyph_index--;
+	  
+	  if (glyph_index < 0)
+	    {
+	      iter->end_index = item->offset + item->length;
+	      iter->end_char = item->num_chars;
+	      break;
+	    }
+	  
+	  if (item->offset + glyphs->log_clusters[glyph_index] != iter->start_index)
+	    {
+	      iter->end_index = item->offset + glyphs->log_clusters[glyph_index];
+	      iter->end_char += g_utf8_strlen (iter->text + iter->start_index,
+					       iter->end_index - iter->start_index);
+	      break; 
+	    }
+	}
+    }
+
+  iter->end_glyph = glyph_index;
+  return TRUE;
+}
+
+/**
+ * _pango_glyph_item_iter_init_start:
+ * @iter: pointer to a #PangoGlyphItemIter structure
+ * @glyph_item: the glyph item that the iter points into
+ * @text: text corresponding to the glyph item
+ * 
+ * Initializes a #PangoGlyphItemIter structure to point to the
+ * first cluster in a glyph item.
+ * 
+ * Return value: %FALSE if there are no clusters in the glyph item;
+ *  in this case, the state of the iter is undefined.
+ **/
+static gboolean
+_pango_glyph_item_iter_init_start (PangoGlyphItemIter  *iter,
+				   PangoGlyphItem      *glyph_item,
+				   const char          *text)
+{
+  iter->glyph_item = glyph_item;
+  iter->text = text;
+  
+  if (LTR (glyph_item))
+    iter->end_glyph = 0;
+  else
+    iter->end_glyph = glyph_item->glyphs->num_glyphs - 1;
+
+  iter->end_index = glyph_item->item->offset;
+  iter->end_char = 0;
+
+  /* Advance onto the first cluster of the glyph item */
+  return _pango_glyph_item_iter_next_cluster (iter);
+}
+
 
 void
-nsFontMetricsPango::DrawStringSlowly(const gchar *aText,
-                                     const PRUnichar *aOrigString,
-                                     PRUint32 aLength,
-                                     GdkDrawable *aDrawable,
-                                     GdkGC *aGC, gint aX, gint aY,
-                                     PangoLayoutLine *aLine,
-                                     const nscoord *aSpacing)
-{
-    float app2dev;
-    app2dev = mDeviceContext->AppUnitsToDevUnits();
-    gint offset = 0;
+nsFontMetricsPango::ApplySpacing(const gchar *aText,
+                                 PRUint32 aLength,
+                                 PangoLayoutLine *aLine,
+                                 const nscoord *aSpacing)
+{
+    if (!(aSpacing && *aSpacing))
+      return;
+
+    float app2dev = mDeviceContext->AppUnitsToDevUnits();
 
     /*
      * We walk the list of glyphs returned in each layout run,
      * matching up the glyphs with the characters in the source text.
      * We use the aSpacing argument to figure out where to place those
-     * glyphs.  It's important to note that since the string we're
-     * working with is in UTF-8 while the spacing argument assumes
-     * that offset will be part of the UTF-16 string.  Logical
-     * attributes in pango are in byte offsets in the UTF-8 string, so
-     * we need to store the offsets based on the UTF-8 string.
+     * glyphs.
      */
-    nscoord *utf8spacing = new nscoord[strlen(aText)];
+    for (GSList *tmpList = aLine->runs; tmpList && tmpList->data;
+         tmpList = tmpList->next) {
+        PangoGlyphItem *glyph_item = (PangoGlyphItem *)tmpList->data;
+        PangoGlyphItemIter iter;
+        gboolean have_cluster;
+        PangoGlyphInfo *glyphs = glyph_item->glyphs->glyphs;
+        int residualWidth = 0;
+
+        for (have_cluster = _pango_glyph_item_iter_init_start (&iter, glyph_item, aText);
+             have_cluster;
+             have_cluster = _pango_glyph_item_iter_next_cluster (&iter))
+        {
+          int clusterOldWidth = 0;
+          int clusterNewWidth = 0;
+          int dir = iter.start_glyph < iter.end_glyph ? +1 : -1;
+          gboolean has_zero_width = FALSE;
+
+          for (const char *p = iter.text + iter.start_index;
+               p < iter.text + iter.end_index;
+               p = g_utf8_next_char (p))
+            clusterNewWidth += aSpacing[p - iter.text];
+
+          clusterNewWidth = (gint)(clusterNewWidth * app2dev * PANGO_SCALE);
+
+          for (gint i = iter.start_glyph; i != iter.end_glyph; i += dir) {
+            if (!glyphs[i].geometry.width)
+              has_zero_width = TRUE;
+            clusterOldWidth += glyphs[i].geometry.width;
+          }
+            
+          /* if a zero-width glyph exists, don't touch the glyph widths.
+           * required for combining marks.  ff thinks they have a width.
+           * instead, we charge the difference to the next space glyph. */
+          if (has_zero_width) {
+            residualWidth += clusterNewWidth - clusterOldWidth;
+            continue;
+          }
 
-    if (aOrigString) {
-        const gchar *curChar = aText;
-        bzero(utf8spacing, sizeof(nscoord) * strlen(aText));
-
-        // Covert the utf16 spacing offsets to utf8 spacing offsets
-        for (PRUint32 curOffset=0; curOffset < aLength;
-             curOffset++, curChar = g_utf8_find_next_char(curChar, NULL)) {
-            utf8spacing[curChar - aText] = aSpacing[curOffset];
+          /* If a space glyph is found, charge it whatever residual we
+           * have accumulated so far. */
+          if (iter.end_index - iter.start_index == 1 &&
+              *(iter.text + iter.start_index) == ' ') {
+            clusterNewWidth += residualWidth;
+            residualWidth = 0;
+          }
+          
+#ifndef PSPANGO
+          /* do some hinting for display */
+
+          if (clusterOldWidth % PANGO_SCALE == 0 && clusterNewWidth % PANGO_SCALE != 0) {
+            int tmp = clusterNewWidth;
+            clusterNewWidth = PANGO_PIXELS (clusterNewWidth) * PANGO_SCALE;
+            residualWidth += tmp - clusterNewWidth;
+          }
+#endif
 
-            if (IS_HIGH_SURROGATE(aOrigString[curOffset]))
-                curOffset++;
+          /* find the first non-zero-width glyph and adjust its width */
+          for (gint i = iter.start_glyph; i != iter.end_glyph; i += dir)
+            if (glyphs[i].geometry.width) {
+              glyphs[i].geometry.width += clusterNewWidth - clusterOldWidth;
+              break;
+            }
         }
     }
-    else {
-        memcpy(utf8spacing, aSpacing, (sizeof(nscoord *) * aLength));
-    }
+}
 
-    gint curRun = 0;
+void
+nsFontMetricsPango::ApplySpacing(const PRUnichar *aText,
+                                 PRUint32 aLength,
+                                 PangoLayoutLine *aLine,
+                                 const nscoord *aSpacing)
+{
+    if (!(aSpacing && *aSpacing))
+      return;
 
-    for (GSList *tmpList = aLine->runs; tmpList && tmpList->data;
-         tmpList = tmpList->next, curRun++) {
-        PangoLayoutRun *layoutRun = (PangoLayoutRun *)tmpList->data;
-        gint tmpOffset = 0;
+    const char *utf8Text = pango_layout_get_text (aLine->layout);
+    int utf8Text_len = aLine->start_index + aLine->length;
+
+    /* Since the string we're
+     * working with is in UTF-8 while the spacing argument assumes
+     * that offset will be part of the UTF-16 string.  Logical
+     * attributes in pango are in byte offsets in the UTF-8 string, so
+     * we need to store the offsets based on the UTF-8 string.
+     */
+    nscoord *utf8spacing = g_new0 (nscoord, utf8Text_len);
 
-        /*        printf("    Rendering run %d: \"%s\"\n", curRun,
-                  &aText[layoutRun->item->offset]); */
+    const gchar *curChar = utf8Text + aLine->start_index;
 
-        for (gint i=0; i < layoutRun->glyphs->num_glyphs; i++) {
-            /* printf("glyph %d offset %d orig width %d new width %d\n", i,
-             *        layoutRun->glyphs->log_clusters[i] + layoutRun->item->offset,
-             *        layoutRun->glyphs->glyphs[i].geometry.width,
-             *       (gint)(utf8spacing[layoutRun->glyphs->log_clusters[i] + layoutRun->item->offset] * app2dev * PANGO_SCALE));
-             */
-            gint thisOffset = (gint)(utf8spacing[layoutRun->glyphs->log_clusters[i] + layoutRun->item->offset]
-                                     * app2dev * PANGO_SCALE);
-            layoutRun->glyphs->glyphs[i].geometry.width = thisOffset;
-            tmpOffset += thisOffset;
-        }
+    // Covert the utf16 spacing offsets to utf8 spacing offsets
+    for (PRUint32 curOffset=0; curOffset < aLength;
+         curOffset++, curChar = g_utf8_next_char(curChar)) {
+        utf8spacing[curChar - utf8Text] = aSpacing[curOffset];
 
-        /*        printf("    rendering at X coord %d\n", aX + offset); */
-        offset += tmpOffset;
+        if (IS_HIGH_SURROGATE(aText[curOffset]))
+            curOffset++;
     }
 
-    gdk_draw_layout_line(aDrawable, aGC, aX, aY, aLine);
+    ApplySpacing (utf8Text, utf8Text_len, aLine, utf8spacing);
 
-    delete[] utf8spacing;
+    g_free (utf8spacing);
 }
 
 nsresult
@@ -1357,8 +1660,8 @@
                                               PRInt32             aNumBreaks,
                                               nsTextDimensions&   aDimensions,
                                               PRInt32&            aNumCharsFit,
-                                              nsTextDimensions&   aLastWordDimensions,
-                                              nsRenderingContextGTK *aContext)
+                                              nsTextDimensions&   aLastWordDimensions
+                                              CONTEXT_ARG_DEF)
 {
     NS_PRECONDITION(aBreaks[aNumBreaks - 1] == aLength, "invalid break array");
 
@@ -1404,7 +1707,7 @@
             // All the characters should fit
             numChars = aLength - start;
             breakIndex = aNumBreaks - 1;
-        } 
+        }
         else {
             breakIndex = prevBreakState_BreakIndex;
             while (((breakIndex + 1) < aNumBreaks) &&
@@ -1425,7 +1728,7 @@
         if ((1 == numChars) && (aString[start] == ' '))
             GetSpaceWidth(twWidth);
         else if (numChars > 0)
-            GetWidth(&aString[start], numChars, twWidth, aContext);
+            GetWidth(&aString[start], numChars, twWidth CONTEXT_ARG_PASS);
 
         // See if the text fits
         PRBool  textFits = (twWidth + width) <= aAvailWidth;
@@ -1475,8 +1778,7 @@
                 if ((1 == numChars) && (aString[start] == ' '))
                     GetSpaceWidth(twWidth);
                 else if (numChars > 0)
-                    GetWidth(&aString[start], numChars, twWidth,
-                             aContext);
+                    GetWidth(&aString[start], numChars, twWidth CONTEXT_ARG_PASS);
                 width -= twWidth;
                 aNumCharsFit = start;
                 breakIndex--;
@@ -1498,9 +1800,16 @@
 }
 
 void
-nsFontMetricsPango::FixupSpaceWidths (PangoLayout *aLayout,
-                                      const char *aString)
+nsFontMetricsPango::FixupSpaceWidths (PangoLayout *aLayout)
 {
+    if (!mPangoSpaceWidth)
+      return;
+
+    const char *aString = pango_layout_get_text (aLayout);
+
+    if (pango_layout_get_line_count(aLayout) != 1) {
+        printf("Warning: more than one line!\n");
+    }
     PangoLayoutLine *line = pango_layout_get_line(aLayout, 0);
 
     gint curRun = 0;
@@ -1517,6 +1826,107 @@
     }
 }
 
+PangoLayout*
+nsFontMetricsPango::GetLayout (const PRUnichar* aText,
+                               PRUint32         aLength)
+{
+  gchar* text;
+  gint length;
+  utf16_to_utf8 (aText, aLength, text, length);
+
+  PangoLayout *layout = pango_layout_new(mPangoContext);
+  pango_layout_set_text (layout, text, length);
+  FixupSpaceWidths (layout);
+
+  g_free ((gpointer) text);
+
+  return layout;
+}
+
+PangoLayout*
+nsFontMetricsPango::GetLayout (const gchar*     aText,
+                               PRInt32          aLength)
+{
+  gboolean has_nul = FALSE;
+  int i;
+
+  for (i = 0; i < aLength; i++)
+    if (!aText[i]) {
+      has_nul = TRUE;
+      break;
+    }
+
+  if (has_nul) {
+    /* Pango doesn't correctly handle nuls.  We convert them to 0xff. */
+
+    char *p = (char *) g_memdup (aText, aLength);
+
+    /* don't need to reset i */
+    for (; i < aLength; i++)
+      if (!p[i])
+        p[i] = (char) 0xff;
+
+    aText = p;
+  }
+
+  PangoLayout *layout = pango_layout_new(mPangoContext);
+  pango_layout_set_text (layout, aText, aLength);
+  FixupSpaceWidths (layout);
+
+  if (has_nul)
+    g_free ((gpointer) aText);
+
+  return layout;
+}
+
+static void
+utf16_to_utf8 (const PRUnichar* aText, PRUint32 aLength, char *&text, gint &length)
+{
+  gboolean need_copy = FALSE;
+  int i;
+
+  for (i = 0; i < aLength; i++) {
+    if (!aText[i] || IS_LOW_SURROGATE (aText[i]))
+      need_copy = TRUE;
+    else if (IS_HIGH_SURROGATE (aText[i])) {
+      if (i < aLength - 1 && IS_LOW_SURROGATE (aText[i+1]))
+        i++;
+      else
+        need_copy = TRUE;
+    }
+  }
+
+  if (need_copy) {
+
+    /* Pango doesn't correctly handle nuls.  We convert them to 0xff. */
+    /* Also "validate" UTF-16 text to make sure conversion doesn't fail. */
+
+    PRUnichar *p = (PRUnichar *) g_memdup (aText, aLength * sizeof (aText[0]));
+
+    /* don't need to reset i */
+    for (i = 0; i < aLength; i++) {
+      if (!p[i] || IS_LOW_SURROGATE (p[i]))
+        p[i] = 0xFFFD;
+      else if (IS_HIGH_SURROGATE (p[i])) {
+        if (i < aLength - 1 && IS_LOW_SURROGATE (aText[i+1]))
+          i++;
+        else
+          p[i] = 0xFFFD;
+      }
+    }
+
+    aText = p;
+  }
+
+  glong items_written;
+  text = g_utf16_to_utf8 (aText, aLength, NULL, &items_written, NULL);
+  length = items_written;
+
+  if (need_copy)
+    g_free ((gpointer) aText);
+
+}
+
 /* static */
 PangoLanguage *
 GetPangoLanguage(nsIAtom *aLangGroup)
--- mozilla/gfx/src/ps/nsFontMetricsPS.h.pango-printing	2006-12-01 16:23:16.000000000 -0500
+++ mozilla/gfx/src/ps/nsFontMetricsPS.h	2006-12-01 16:26:27.000000000 -0500
@@ -66,6 +66,7 @@
 #endif
 #include "nsVoidArray.h"
 #include "nsHashtable.h"
+#include "nsValueArray.h"
 
 class nsPSFontGenerator;
 class nsDeviceContextPS;
@@ -108,6 +109,65 @@
   NS_IMETHOD  GetFontHandle(nsFontHandle &aHandle);
   NS_IMETHOD  GetStringWidth(const char *String,nscoord &aWidth,nscoord aLength);
   NS_IMETHOD  GetStringWidth(const PRUnichar *aString,nscoord &aWidth,nscoord aLength);
+
+    NS_IMETHOD       GetTextDimensions(const char* aString,
+                                       PRUint32 aLength,
+                                       nsTextDimensions& aDimensions);
+    NS_IMETHOD       GetTextDimensions(const PRUnichar* aString,
+                                       PRUint32 aLength,
+                                       nsTextDimensions& aDimensions, 
+                                       PRInt32* aFontID);
+    NS_IMETHOD       GetTextDimensions(const char*         aString,
+                                       PRInt32             aLength,
+                                       PRInt32             aAvailWidth,
+                                       PRInt32*            aBreaks,
+                                       PRInt32             aNumBreaks,
+                                       nsTextDimensions&   aDimensions,
+                                       PRInt32&            aNumCharsFit,
+                                       nsTextDimensions&   aLastWordDimensions,
+                                       PRInt32*            aFontID);
+    NS_IMETHOD       GetTextDimensions(const PRUnichar*    aString,
+                                       PRInt32             aLength,
+                                       PRInt32             aAvailWidth,
+                                       PRInt32*            aBreaks,
+                                       PRInt32             aNumBreaks,
+                                       nsTextDimensions&   aDimensions,
+                                       PRInt32&            aNumCharsFit,
+                                       nsTextDimensions&   aLastWordDimensions,
+                                       PRInt32*            aFontID);
+#ifdef MOZ_MATHML
+    NS_IMETHOD       GetBoundingMetrics(const char *aString, PRUint32 aLength,
+                                        nsBoundingMetrics &aBoundingMetrics);
+    NS_IMETHOD       GetBoundingMetrics(const PRUnichar *aString,
+                                        PRUint32 aLength,
+                                        nsBoundingMetrics &aBoundingMetrics,
+                                        PRInt32 *aFontID);
+#endif /* MOZ_MATHML */
+
+  NS_IMETHOD DrawString(const char *aString, PRUint32 aLength,
+                        nscoord aX, nscoord aY,
+                        const nscoord* aSpacing,
+			nsRenderingContextPS *aContext);
+  NS_IMETHOD DrawString(const PRUnichar *aString, PRUint32 aLength,
+                        nscoord aX, nscoord aY,
+                        PRInt32 aFontID,
+                        const nscoord* aSpacing,
+			nsRenderingContextPS *aContext);
+
+protected:
+  PRInt32 DrawString(const char *aString, PRUint32 aLength,
+                        nscoord aX, nscoord aY, nsFontPS* aFontPS,
+                        const nscoord* aSpacing,
+			nsRenderingContextPS *aContext);
+  PRInt32 DrawString(const PRUnichar *aString, PRUint32 aLength,
+                        nscoord &aX, nscoord &aY, nsFontPS* aFontPS,
+                        const nscoord* aSpacing,
+			nsRenderingContextPS *aContext);
+
+public:
+
+  virtual PRUint32    GetHints     (void) { return 0; }
+
   
   inline void SetXHeight(nscoord aXHeight) { mXHeight = aXHeight; };
   inline void SetSuperscriptOffset(nscoord aSuperscriptOffset) { mSuperscriptOffset = aSuperscriptOffset; };
@@ -455,16 +515,14 @@
   nsPSFontGenerator();
   virtual ~nsPSFontGenerator();
   virtual void  GeneratePSFont(FILE* aFile);
-  PRInt32  AddToSubset(PRUnichar aChar);
-  nsString *GetSubset();
+  PRInt32  AddToGlyphSubset(PRUint32 aGlyph);
+  PRInt32  InSubsetIndexOf(PRUint32 aGlyph);
 
   // 256 (PS type 1 encoding vector size) - 1 (1 is for mandatory /.notdef)
   const static PRUint16 kSubFontSize; 
 
 protected:
-  // XXX To support non-BMP characters, we may have to use 
-  // nsValueArray with PRUint32
-  nsString mSubset;
+  nsValueArray *mGlyphSubset;
 };
 
 
--- mozilla/gfx/src/ps/nsRenderingContextPS.h.pango-printing	2006-12-01 16:23:16.000000000 -0500
+++ mozilla/gfx/src/ps/nsRenderingContextPS.h	2006-12-01 16:26:27.000000000 -0500
@@ -154,6 +154,10 @@
   NS_IMETHOD GetWidth(const PRUnichar* aString, PRUint32 aLength,
                       nscoord& aWidth, PRInt32 *aFontID);
 
+  nsTransform2D *GetTranMatrix() {
+    return mTranMatrix;
+  }
+
   NS_IMETHOD DrawString(const char *aString, PRUint32 aLength,
                         nscoord aX, nscoord aY,
                         const nscoord* aSpacing);
@@ -164,13 +168,6 @@
   NS_IMETHOD DrawString(const nsString& aString, nscoord aX, nscoord aY,
                         PRInt32 aFontID,
                         const nscoord* aSpacing);
-protected:
-  PRInt32 DrawString(const PRUnichar *aString, PRUint32 aLength,
-                        nscoord aX, nscoord aY, nsFontPS* aFontPS,
-                        const nscoord* aSpacing);
-  PRInt32 DrawString(const char *aString, PRUint32 aLength,
-                        nscoord &aX, nscoord &aY, nsFontPS* aFontPS,
-                        const nscoord* aSpacing);
 public:
 
   NS_IMETHOD GetTextDimensions(const char* aString, PRUint32 aLength,
--- mozilla/gfx/src/ps/nsPostScriptObj.cpp.pango-printing	2006-12-01 16:23:16.000000000 -0500
+++ mozilla/gfx/src/ps/nsPostScriptObj.cpp	2006-12-01 16:26:27.000000000 -0500
@@ -47,6 +47,10 @@
  * 10/09/2000       IPLabs Linux Team      True Unicode glyps support added.
  */
 
+#ifdef MOZ_ENABLE_PANGO
+#define PANGO_ENABLE_BACKEND
+#endif
+
 #include "gfx-config.h"
  
 #define FORCE_PR_LOG /* Allow logging in the release build */
@@ -87,6 +91,12 @@
 #include <errno.h>
 #include <sys/wait.h>
 
+#ifdef MOZ_ENABLE_PANGO
+#ifndef PANGO_GLYPH_EMPTY
+#define PANGO_GLYPH_EMPTY 0
+#endif
+#endif
+
 #ifdef PR_LOGGING
 static PRLogModuleInfo *nsPostScriptObjLM = PR_NewLogModule("nsPostScriptObj");
 #endif /* PR_LOGGING */
@@ -2061,34 +2071,98 @@
 
 #if defined(MOZ_ENABLE_FREETYPE2) || defined(MOZ_ENABLE_XFT)
 void 
-nsPostScriptObj::show(const PRUnichar* aTxt, int aLen,
-                      const nsAFlatString& aCharList, PRUint16 aSubFontIdx)
+/*nsPostScriptObj::show(const PRUnichar* aTxt, int aLen,
+  const nsAFlatString& aCharList, PRUint16 aSubFontIdx) */
+nsPostScriptObj::show(const nsValueArray *aGlyphs, nsPSFontGenerator *aSubset,
+                      PRUint16 aSubFontIdx)
 {
-  int i;
+  PRUint32 i;
   fputc('<', mScriptFP);
 
-  const PRUint16 subFontSize = nsPSFontGenerator::kSubFontSize;
-
-  // the character repertoire of a subfont (255 characters max)
-  const nsAString& repertoire = 
-        Substring(aCharList, aSubFontIdx * subFontSize,
-                  PR_MIN(subFontSize, 
-                  aCharList.Length() - aSubFontIdx * subFontSize));
-
-  for (i = 0; i < aLen; i++) {
-    // XXX This is a little inefficient, but printing is not perf. critical. 
-    NS_ASSERTION(repertoire.FindChar(aTxt[i]) != kNotFound,
-        "character is not covered by this subfont");
-      
-    // Type 1 encoding vector has 256 slots, but the 0-th slot is 
-    // reserved for /.notdef so that we use the 1st through 255th slots
-    // for actual characters (hence '+ 1')
-    fprintf(mScriptFP, "%02x", repertoire.FindChar(aTxt[i]) + 1); 
+  for (i = 0; i < aGlyphs->Count(); i++) {
+    PRUint32 glyph = aGlyphs->ValueAt(i);
+    fprintf(mScriptFP, "%02x", aSubset->InSubsetIndexOf(glyph));
   }
+
   fputs("> show\n", mScriptFP);
 }
 #endif
 
+#ifdef MOZ_ENABLE_PANGO
+void
+nsPostScriptObj::show(const PangoGlyphString *glyphs, float zoom, 
+                      nsPSFontGenerator *aSubset, PRUint16 aSubFontIdx)
+{
+  PRUint32 i, start;
+  int horiz = 1;
+  int x_off = 0, y_off = 0;
+
+  /* skip inital empty glyphs */
+  for (i = 0; i < glyphs->num_glyphs && glyphs->glyphs[i].glyph == PANGO_GLYPH_EMPTY; i++)
+    x_off += glyphs->glyphs[i].geometry.width;
+  start = i;
+
+  if (start >= glyphs->num_glyphs)
+    return;
+
+  x_off += glyphs->glyphs[start].geometry.x_offset;
+  y_off += glyphs->glyphs[start].geometry.y_offset;
+  /* do we need an initial move? */
+  if (x_off || y_off) {
+    rmoveto (NSToCoordRound (zoom * x_off / PANGO_SCALE),
+             NSToCoordRound (zoom * y_off / PANGO_SCALE));
+  }
+
+  fputc('<', mScriptFP);
+
+  /* write the glyphs out.  see if it's horizontal */
+  for (i = start; i < glyphs->num_glyphs; i++) {
+    PRUint32 glyph = glyphs->glyphs[i].glyph;
+
+    if (glyph == PANGO_GLYPH_EMPTY)
+      continue;
+
+    fprintf(mScriptFP, "%02x", aSubset->InSubsetIndexOf(glyph));
+    if (glyphs->glyphs[i].geometry.y_offset)
+      horiz = 0;
+  }
+  
+  /* write out the advance vector and show */
+  i = start;
+  x_off = -glyphs->glyphs[i].geometry.x_offset + glyphs->glyphs[i].geometry.width;
+  y_off = -glyphs->glyphs[i].geometry.y_offset;
+  i++;
+  fputs(">\n[", mScriptFP);
+
+  for (; i < glyphs->num_glyphs; i++) {
+    PangoGlyphInfo *gli = glyphs->glyphs + i;
+
+    if (gli->glyph == PANGO_GLYPH_EMPTY) {
+      x_off += gli->geometry.width;
+      continue;
+    }
+
+    x_off += gli->geometry.x_offset;
+    fprintf(mScriptFP, "%d ", NSToCoordRound (zoom * x_off / PANGO_SCALE));
+    x_off = -gli->geometry.x_offset + gli->geometry.width;
+
+    if (horiz)
+      continue;
+
+    y_off += gli->geometry.y_offset;
+    fprintf(mScriptFP, "%d ", NSToCoordRound (zoom * y_off / PANGO_SCALE));
+    y_off = -gli->geometry.y_offset;
+  }
+  fprintf(mScriptFP, "%d", NSToCoordRound (zoom * x_off / PANGO_SCALE));
+  if (horiz)
+    fputs("] xshow\n", mScriptFP);
+  else {
+    fprintf(mScriptFP, " %d", NSToCoordRound (zoom * y_off / PANGO_SCALE));
+    fputs("] xyshow\n", mScriptFP);
+  }
+}
+#endif
+
 /** ---------------------------------------------------
  *  See documentation in nsPostScriptObj.h
  *	@update 2/1/99 dwc
@@ -2101,6 +2175,16 @@
 
 /** ---------------------------------------------------
  *  See documentation in nsPostScriptObj.h
+ *	@update 10/20/06 behdad
+ */
+void 
+nsPostScriptObj::rmoveto(nscoord x, nscoord y)
+{
+  fprintf(mScriptFP, "%d %d rmoveto\n", x, y);
+}
+
+/** ---------------------------------------------------
+ *  See documentation in nsPostScriptObj.h
  *	@update 2/1/99 dwc
  */
 void 
--- mozilla/gfx/src/ps/nsFontMetricsPS.cpp.pango-printing	2006-12-01 16:23:16.000000000 -0500
+++ mozilla/gfx/src/ps/nsFontMetricsPS.cpp	2006-12-01 16:26:27.000000000 -0500
@@ -461,6 +461,239 @@
   return NS_OK;
 }
 
+nsresult
+nsFontMetricsPS::DrawString(const char *aString, PRUint32 aLength,
+                               nscoord aX, nscoord aY,
+                               const nscoord* aSpacing,
+                               nsRenderingContextPS *aContext)
+{
+  nsPostScriptObj* psObj = aContext->GetPostScriptObj();
+  // When FT2 printing is enabled, we don't need to set langgroup
+#if defined(MOZ_ENABLE_FREETYPE2) || defined(MOZ_ENABLE_XFT)
+  if (!NS_REINTERPRET_CAST(nsDeviceContextPS *, GetDeviceContext())->mFTPEnable) {
+#endif
+    nsCOMPtr<nsIAtom> langGroup;
+    GetLangGroup(getter_AddRefs(langGroup));
+    psObj->setlanggroup(langGroup);
+#if defined(MOZ_ENABLE_FREETYPE2) || defined(MOZ_ENABLE_XFT)
+  }
+#endif
+
+  if (aLength == 0)
+    return NS_OK;
+  nsFontPS* fontPS = nsFontPS::FindFont(aString[0], Font(), this);
+  NS_ENSURE_TRUE(fontPS, NS_ERROR_FAILURE);
+  fontPS->SetupFont(aContext);
+
+  PRUint32 i, start = 0;
+  for (i=0; i<aLength; i++) {
+    nsFontPS* fontThisChar;
+    fontThisChar = nsFontPS::FindFont(aString[i], Font(), this);
+    NS_ENSURE_TRUE(fontThisChar, NS_ERROR_FAILURE);
+    if (fontThisChar != fontPS) {
+      // draw text up to this point
+      aX += DrawString(aString+start, i-start, aX, aY, fontPS, 
+                       aSpacing?aSpacing+start:nsnull, aContext);
+      start = i;
+
+      // setup for following text
+      fontPS = fontThisChar;
+      fontPS->SetupFont(aContext);
+    }
+  }
+
+  // draw the last part
+  if (aLength-start)
+    DrawString(aString+start, aLength-start, aX, aY, fontPS, 
+               aSpacing?aSpacing+start:nsnull, aContext);
+
+  return NS_OK;
+}
+
+nsresult
+nsFontMetricsPS::DrawString(const PRUnichar* aString, PRUint32 aLength,
+                               nscoord aX, nscoord aY,
+                               PRInt32 aFontID,
+                               const nscoord* aSpacing,
+                               nsRenderingContextPS *aContext)
+{
+  nsPostScriptObj* psObj = aContext->GetPostScriptObj();
+#if defined(MOZ_ENABLE_FREETYPE2) || defined(MOZ_ENABLE_XFT)
+  // When FT2 printing is enabled, we don't need to set langgroup
+  if (!NS_REINTERPRET_CAST(nsDeviceContextPS *, GetDeviceContext())->mFTPEnable) {
+#endif
+    nsCOMPtr<nsIAtom> langGroup = nsnull;
+    GetLangGroup(getter_AddRefs(langGroup));
+    psObj->setlanggroup(langGroup);
+#if defined(MOZ_ENABLE_FREETYPE2) || defined(MOZ_ENABLE_XFT)
+  }
+#endif
+
+  /* build up conversion table */
+  psObj->preshow(aString, aLength);
+
+  if (aLength == 0)
+    return NS_OK;
+  nsFontPS* fontPS = nsFontPS::FindFont(aString[0], Font(), this);
+  NS_ENSURE_TRUE(fontPS, NS_ERROR_FAILURE);
+  fontPS->SetupFont(aContext);
+
+  PRUint32 i, start = 0;
+  for (i=0; i<aLength; i++) {
+    nsFontPS* fontThisChar;
+    fontThisChar = nsFontPS::FindFont(aString[i], Font(), this);
+    NS_ENSURE_TRUE(fontThisChar, NS_ERROR_FAILURE);
+    if (fontThisChar != fontPS) {
+      // draw text up to this point
+      aX += DrawString(aString+start, i-start, aX, aY, fontPS, 
+                       aSpacing?aSpacing+start:nsnull, aContext);
+      start = i;
+
+      // setup for following text
+      fontPS = fontThisChar;
+      fontPS->SetupFont(aContext);
+    }
+  }
+
+  // draw the last part
+  if (aLength-start)
+    DrawString(aString+start, aLength-start, aX, aY, fontPS, 
+               aSpacing?aSpacing+start:nsnull, aContext);
+
+  return NS_OK;
+}
+
+PRInt32
+nsFontMetricsPS::DrawString(const char *aString, PRUint32 aLength,
+                        nscoord aX, nscoord aY, nsFontPS* aFontPS,
+                        const nscoord* aSpacing,
+			nsRenderingContextPS *aContext)
+{
+  nscoord width = 0;
+  PRInt32 x = aX;
+  PRInt32 y = aY;
+
+  PRInt32 dxMem[500];
+  PRInt32* dx0 = 0;
+  if (aSpacing) {
+    dx0 = dxMem;
+    if (aLength > 500) {
+      dx0 = new PRInt32[aLength];
+      NS_ENSURE_TRUE(dx0, NS_ERROR_OUT_OF_MEMORY);
+    }
+    aContext->GetTranMatrix()->ScaleXCoords(aSpacing, aLength, dx0);
+  }
+
+  aContext->GetTranMatrix()->TransformCoord(&x, &y);
+  width = aFontPS->DrawString(aContext, x, y, aString, aLength);
+
+  if ((aSpacing) && (dx0 != dxMem)) {
+    delete [] dx0;
+  }
+
+  return width;
+}
+
+
+PRInt32
+nsFontMetricsPS::DrawString(const PRUnichar* aString, PRUint32 aLength,
+                                 nscoord &aX, nscoord &aY, nsFontPS* aFontPS,
+                                 const nscoord* aSpacing,
+				 nsRenderingContextPS *aContext)
+{
+  nscoord width = 0;
+  PRInt32 x = aX;
+  PRInt32 y = aY;
+
+  if (aSpacing) {
+    // Slow, but accurate rendering
+    const PRUnichar* end = aString + aLength;
+    while (aString < end){
+      x = aX;
+      y = aY;
+      aContext->GetTranMatrix()->TransformCoord(&x, &y);
+      aFontPS->DrawString(aContext, x, y, aString, 1);
+      aX += *aSpacing++;
+      aString++;
+    }
+    width = aX;
+  } else {
+    aContext->GetTranMatrix()->TransformCoord(&x, &y);
+    width = aFontPS->DrawString(aContext, x, y, aString, aLength);
+  }
+
+  return width;
+}
+
+NS_IMETHODIMP
+nsFontMetricsPS::GetTextDimensions(const char*       aString,
+                                        PRInt32           aLength,
+                                        PRInt32           aAvailWidth,
+                                        PRInt32*          aBreaks,
+                                        PRInt32           aNumBreaks,
+                                        nsTextDimensions& aDimensions,
+                                        PRInt32&          aNumCharsFit,
+                                        nsTextDimensions& aLastWordDimensions,
+                                        PRInt32*          aFontID)
+{
+  NS_NOTYETIMPLEMENTED("nsFontMetricsPS::GetTextDimensions");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsFontMetricsPS::GetTextDimensions(const PRUnichar*  aString,
+                                        PRInt32           aLength,
+                                        PRInt32           aAvailWidth,
+                                        PRInt32*          aBreaks,
+                                        PRInt32           aNumBreaks,
+                                        nsTextDimensions& aDimensions,
+                                        PRInt32&          aNumCharsFit,
+                                        nsTextDimensions& aLastWordDimensions,
+                                        PRInt32*          aFontID)
+{
+  NS_NOTYETIMPLEMENTED("nsFontMetricsPS::GetTextDimensions");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsFontMetricsPS :: GetTextDimensions(const char* aString, PRUint32 aLength,
+                                          nsTextDimensions& aDimensions)
+{
+  GetStringWidth(aString, aDimensions.width, aLength);
+  GetMaxAscent(aDimensions.ascent);
+  GetMaxDescent(aDimensions.descent);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsFontMetricsPS :: GetTextDimensions(const PRUnichar* aString, PRUint32 aLength,
+                                          nsTextDimensions& aDimensions, PRInt32* aFontID)
+{
+  GetStringWidth(aString, aDimensions.width, aLength);
+  //XXX temporary - bug 96609
+  GetMaxAscent(aDimensions.ascent);
+  GetMaxDescent(aDimensions.descent);
+  return NS_OK;
+}
+
+nsresult
+nsFontMetricsPS::GetBoundingMetrics(const char*        aString,
+                                     PRUint32           aLength,
+                                     nsBoundingMetrics& aBoundingMetrics)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult
+nsFontMetricsPS::GetBoundingMetrics(const PRUnichar*   aString,
+                                     PRUint32           aLength,
+                                     nsBoundingMetrics &aBoundingMetrics,
+                                     PRInt32 *aFontID)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+
 nsFontPS*
 nsFontPS::FindFont(char aChar, const nsFont& aFont, 
                    nsFontMetricsPS* aFontMetrics)
@@ -986,10 +1219,6 @@
         result = FcPatternGetCharSet(set->fonts[i], FC_CHARSET, 0, &fc_charset);
         if (result != FcResultMatch || fc_charset == nsnull)
           continue;
-        // increment reference count
-        fc_charset = FcCharSetCopy(fc_charset);
-        if (fc_charset == nsnull)
-          continue;
 
         nsXftEntry *xftEntry = new nsXftEntry(set->fonts[i]);
         if (!xftEntry)
@@ -997,7 +1226,7 @@
 
         fontps *fps = new fontps;
         fps->entry = xftEntry;
-        fps->charset = fc_charset;
+        fps->charset = FcCharSetCopy (fc_charset);
         fps->fontps = nsnull;
         fpi.fontps->AppendElement(fps);
     }
@@ -1132,23 +1361,38 @@
   PRUint32 start = 0;
   PRUint32 i;
 
+  FT_Face face = getFTFace();
+  if (!face) {
+    NS_WARNING("Failed to get FT Face in nsFontPSXft::DrawString\n");
+    return 0;
+  }
+
+  nsValueArray glyphs(PR_UINT16_MAX);
+
   // XXX : ignore surrogate pairs for now
-  nsString *subSet = mPSFontGenerator->GetSubset();
   for (i = 0; i < aLength; ++i) {
-    currSubFont = mPSFontGenerator->AddToSubset(aString[i]);
+    PRUint32 glyph = FT_Get_Char_Index(face, aString[i]);
+    currSubFont = mPSFontGenerator->AddToGlyphSubset(glyph);
+
+    // Check if we need to render the current string
     if (prevSubFont != currSubFont) {
-      if (prevSubFont != -1)
-        psObj->show(&aString[start], i - start, *subSet, prevSubFont);
+      if (prevSubFont != -1) {
+        psObj->show(&glyphs, mPSFontGenerator, prevSubFont);
+      }
       NS_ASSERTION(!mFontNameBase.IsEmpty(),
                   "font base name shouldn't be empty");
       psObj->setfont(mFontNameBase, mHeight, currSubFont);
       prevSubFont = currSubFont;
       start = i;
+      glyphs.Clear();
     }
+
+    glyphs.AppendValue(glyph);
   }
 
-  if (prevSubFont != -1)
-    psObj->show(&aString[start], i - start, *subSet, prevSubFont); 
+  if (prevSubFont != -1) {
+    psObj->show(&glyphs, mPSFontGenerator, prevSubFont);
+  }
   
   return GetWidth(aString, aLength);
 }
@@ -2282,10 +2526,13 @@
 // Implementation of nsPSFontGenerator
 nsPSFontGenerator::nsPSFontGenerator()
 {
+  mGlyphSubset = new nsValueArray(PR_UINT16_MAX, 40);
 }
 
 nsPSFontGenerator::~nsPSFontGenerator()
 {
+  if (mGlyphSubset)
+    delete mGlyphSubset;
 }
 
 void nsPSFontGenerator::GeneratePSFont(FILE* aFile)
@@ -2293,24 +2540,29 @@
   NS_ERROR("should never call nsPSFontGenerator::GeneratePSFont");
 }
 
-// Add a Unicode character to mSubset which will be divided into 
-// multiple chunks (subfonts) of 255 (kSubFontSize) characters each. 
-// Each chunk will be converted to a Type 1 font. Return the index of 
-// a subfont (chunk) this character belongs to.
+// Add a glyph offset to mSubset which will be divided into multiple
+// chunks (subfonts) of 255 (kSubFontSize) glyphs each.  Each chunk
+// will then be converted into a Type 1 font.  Return the index of a
+// subfont (chunk) this glyph belongs to.
 PRInt32
-nsPSFontGenerator::AddToSubset(PRUnichar aChar)
+nsPSFontGenerator::AddToGlyphSubset(PRUint32 aGlyph)
 {
-  PRInt32 index = mSubset.FindChar(aChar);
-  if (index == kNotFound) {
-    mSubset.Append(aChar);
-    index = mSubset.Length() - 1;
+  nsValueArrayIndex index = mGlyphSubset->IndexOf(aGlyph);
+  if (index == NSVALUEARRAY_INVALID) {
+    mGlyphSubset->AppendValue(aGlyph);
+    index = mGlyphSubset->Count() - 1;
   }
+
   return index / kSubFontSize;
 }
 
-nsString *nsPSFontGenerator::GetSubset()
+PRInt32
+nsPSFontGenerator::InSubsetIndexOf(PRUint32 aGlyph)
 {
-  return &mSubset;
+  nsValueArrayIndex index = mGlyphSubset->IndexOf(aGlyph);
+  if (index == NSVALUEARRAY_INVALID)
+    return 0;
+  return (index % kSubFontSize) + 1;
 }
 
 #ifdef MOZ_ENABLE_XFT
@@ -2357,8 +2609,8 @@
   }
 
   int wmode = 0;
-  if (!mSubset.IsEmpty())
-    FT2SubsetToType1FontSet(face, mSubset, wmode, aFile);
+  if (mGlyphSubset->Count())
+    FT2SubsetToType1FontSet(face, mGlyphSubset, wmode, aFile);
 }
 
 #else
@@ -2406,8 +2658,8 @@
     return;
  
   int wmode = 0;
-  if (!mSubset.IsEmpty())
-    FT2SubsetToType1FontSet(face, mSubset, wmode, aFile);
+  if (mGlyphSubset->Count())
+    FT2SubsetToType1FontSet(face, mGlyphSubset, wmode, aFile);
 }
 
 #endif //MOZ_ENABLE_FREETYPE2
--- mozilla/gfx/src/ps/nsPostScriptObj.h.pango-printing	2006-12-01 16:23:16.000000000 -0500
+++ mozilla/gfx/src/ps/nsPostScriptObj.h	2006-12-01 16:26:27.000000000 -0500
@@ -57,9 +57,15 @@
 #include "nsIPersistentProperties2.h"
 #include "nsTempfilePS.h"
 #include "nsEPSObjectPS.h"
+#ifdef MOZ_ENABLE_PANGO
+#include <pango/pango.h>
+#endif
+
 
+class nsPSFontGenerator;
 class nsIImage;
 class nsIAtom;
+class nsValueArray;
 #endif
 
 #include <stdio.h>
@@ -217,6 +223,14 @@
    */
   void moveto(nscoord aX, nscoord aY);
   /** ---------------------------------------------------
+   *  Move relative to the current point
+   *	@update 10/20/2006 behdad
+   *	@param  aX   X coordinate
+   *	        aY   Y coordinate
+   *    @return VOID
+   */
+  void rmoveto(nscoord aX, nscoord aY);
+  /** ---------------------------------------------------
    *  Add a line to the current path, from the current point
    *  to the specified point.
    *	@update 9/30/2003
@@ -346,12 +360,24 @@
    */
   void show(const PRUnichar* aText, int aLen, const char *aAlign, int aType);
   /** ---------------------------------------------------
-   *  This version takes a PRUnichar string, a font subset string
-   *  for freetype printing and a subfont index
+   *  This version of show takes an array of glyphs, subfont and subfont index
+   *  to render and is used for freetype and xft printing.
    *	@update 2/15/2005 jshin@mailaps.org
+   *    @update 6/7/2005 blizzard@mozilla.org
    */
-  void show(const PRUnichar* aText, int aLen, const nsAFlatString& aCharList,
+  void show(const nsValueArray *aGlyphs, nsPSFontGenerator *aSubset,
             PRUint16 aSubFontIdx);
+  /*void show(const PRUnichar* aText, int aLen, const nsAFlatString& aCharList,
+    PRUint16 aSubFontIdx); */
+#ifdef MOZ_ENABLE_PANGO
+  /** ---------------------------------------------------
+   *  This version of show takes a pango glyph string, subfont and subfont index
+   *  to render and is used for pango printing.
+   *	@update 10/20/2006 behdad@behdad.org
+   */
+  void show(const PangoGlyphString *glyphs, float zoom,
+            nsPSFontGenerator *aSubset, PRUint16 aSubFontIdx);
+#endif
   /** ---------------------------------------------------
    *  set the clipping path to the current path using the winding rule
    *	@update 2/1/99 dwc
--- mozilla/gfx/src/ps/nsType1.h.pango-printing	2006-12-01 16:23:16.000000000 -0500
+++ mozilla/gfx/src/ps/nsType1.h	2006-12-01 16:26:27.000000000 -0500
@@ -122,8 +122,9 @@
 
 class nsString;
 class nsCString;
+class nsValueArray;
 
-PRBool FT2SubsetToType1FontSet(FT_Face aFace, const nsString& aSubset,
+PRBool FT2SubsetToType1FontSet(FT_Face aFace, nsValueArray *aGlyphSubset,
                                int aWmode,  FILE *aFile);
 nsresult FT2ToType1FontName(FT_Face aFace, int aWmode,
                             nsCString& aFontName);
--- mozilla/gfx/src/ps/nsRenderingContextPS.cpp.pango-printing	2006-12-01 16:23:16.000000000 -0500
+++ mozilla/gfx/src/ps/nsRenderingContextPS.cpp	2006-12-01 16:26:27.000000000 -0500
@@ -251,6 +251,8 @@
 NS_IMETHODIMP
 nsRenderingContextPS :: GetHints(PRUint32& aResult)
 {
+  nsFontMetricsPS *metrics = NS_REINTERPRET_CAST(nsFontMetricsPS *, mFontMetrics.get());
+  aResult = metrics->GetHints ();
   return NS_OK;
 }
 
@@ -1006,8 +1008,11 @@
                                         nsTextDimensions& aLastWordDimensions,
                                         PRInt32*          aFontID)
 {
-  NS_NOTYETIMPLEMENTED("nsRenderingContextPS::GetTextDimensions");
-  return NS_ERROR_NOT_IMPLEMENTED;
+  NS_ENSURE_TRUE(mFontMetrics, NS_ERROR_NULL_POINTER);
+  nsFontMetricsPS *metrics = NS_REINTERPRET_CAST(nsFontMetricsPS *, mFontMetrics.get());
+  NS_ENSURE_TRUE(metrics, NS_ERROR_FAILURE);
+  return metrics->GetTextDimensions (aString, aLength, aAvailWidth, aBreaks, aNumBreaks,
+				     aDimensions, aNumCharsFit, aLastWordDimensions, aFontID);
 }
 
 NS_IMETHODIMP
@@ -1021,43 +1026,31 @@
                                         nsTextDimensions& aLastWordDimensions,
                                         PRInt32*          aFontID)
 {
-  NS_NOTYETIMPLEMENTED("nsRenderingContextPS::GetTextDimensions");
-  return NS_ERROR_NOT_IMPLEMENTED;
+  NS_ENSURE_TRUE(mFontMetrics, NS_ERROR_NULL_POINTER);
+  nsFontMetricsPS *metrics = NS_REINTERPRET_CAST(nsFontMetricsPS *, mFontMetrics.get());
+  NS_ENSURE_TRUE(metrics, NS_ERROR_FAILURE);
+  return metrics->GetTextDimensions (aString, aLength, aAvailWidth, aBreaks, aNumBreaks,
+				     aDimensions, aNumCharsFit, aLastWordDimensions, aFontID);
 }
 
 NS_IMETHODIMP
 nsRenderingContextPS :: GetTextDimensions(const char* aString, PRUint32 aLength,
                                           nsTextDimensions& aDimensions)
 {
-  nsresult rv = NS_ERROR_FAILURE;
-
-  if (mFontMetrics) {
-    nsFontMetricsPS *metrics = NS_REINTERPRET_CAST(nsFontMetricsPS *, mFontMetrics.get());
-    metrics->GetStringWidth(aString, aDimensions.width, aLength);
-    metrics->GetMaxAscent(aDimensions.ascent);
-    metrics->GetMaxDescent(aDimensions.descent);
-    rv = NS_OK;
-  }
-  
-  return rv;
+  NS_ENSURE_TRUE(mFontMetrics, NS_ERROR_NULL_POINTER);
+  nsFontMetricsPS *metrics = NS_REINTERPRET_CAST(nsFontMetricsPS *, mFontMetrics.get());
+  NS_ENSURE_TRUE(metrics, NS_ERROR_FAILURE);
+  return metrics->GetTextDimensions (aString, aLength, aDimensions);
 }
 
 NS_IMETHODIMP
 nsRenderingContextPS :: GetTextDimensions(const PRUnichar* aString, PRUint32 aLength,
                                           nsTextDimensions& aDimensions, PRInt32* aFontID)
 {
-  nsresult rv = NS_ERROR_FAILURE;
-
-  if (mFontMetrics) {
-    nsFontMetricsPS *metrics = NS_REINTERPRET_CAST(nsFontMetricsPS *, mFontMetrics.get());
-    metrics->GetStringWidth(aString, aDimensions.width, aLength);
-     //XXX temporary - bug 96609
-    metrics->GetMaxAscent(aDimensions.ascent);
-    metrics->GetMaxDescent(aDimensions.descent);
-    rv = NS_OK;
-  }
-
-  return rv;
+  NS_ENSURE_TRUE(mFontMetrics, NS_ERROR_NULL_POINTER);
+  nsFontMetricsPS *metrics = NS_REINTERPRET_CAST(nsFontMetricsPS *, mFontMetrics.get());
+  NS_ENSURE_TRUE(metrics, NS_ERROR_FAILURE);
+  return metrics->GetTextDimensions (aString, aLength, aDimensions, aFontID);
 }
 
 /** ---------------------------------------------------
@@ -1073,47 +1066,7 @@
 
   nsFontMetricsPS *metrics = NS_REINTERPRET_CAST(nsFontMetricsPS *, mFontMetrics.get());
   NS_ENSURE_TRUE(metrics, NS_ERROR_FAILURE);
-
-  // When FT2 printing is enabled, we don't need to set langgroup
-#if defined(MOZ_ENABLE_FREETYPE2) || defined(MOZ_ENABLE_XFT)
-  if (!NS_REINTERPRET_CAST(nsDeviceContextPS *, mContext.get())->mFTPEnable) {
-#endif
-    nsCOMPtr<nsIAtom> langGroup;
-    mFontMetrics->GetLangGroup(getter_AddRefs(langGroup));
-    mPSObj->setlanggroup(langGroup);
-#if defined(MOZ_ENABLE_FREETYPE2) || defined(MOZ_ENABLE_XFT)
-  }
-#endif
-
-  if (aLength == 0)
-    return NS_OK;
-  nsFontPS* fontPS = nsFontPS::FindFont(aString[0], metrics->Font(), metrics);
-  NS_ENSURE_TRUE(fontPS, NS_ERROR_FAILURE);
-  fontPS->SetupFont(this);
-
-  PRUint32 i, start = 0;
-  for (i=0; i<aLength; i++) {
-    nsFontPS* fontThisChar;
-    fontThisChar = nsFontPS::FindFont(aString[i], metrics->Font(), metrics);
-    NS_ENSURE_TRUE(fontThisChar, NS_ERROR_FAILURE);
-    if (fontThisChar != fontPS) {
-      // draw text up to this point
-      aX += DrawString(aString+start, i-start, aX, aY, fontPS, 
-                       aSpacing?aSpacing+start:nsnull);
-      start = i;
-
-      // setup for following text
-      fontPS = fontThisChar;
-      fontPS->SetupFont(this);
-    }
-  }
-
-  // draw the last part
-  if (aLength-start)
-    DrawString(aString+start, aLength-start, aX, aY, fontPS, 
-               aSpacing?aSpacing+start:nsnull);
-
-  return NS_OK;
+  return metrics->DrawString (aString, aLength, aX, aY, aSpacing, this);
 }
 
 /** ---------------------------------------------------
@@ -1129,110 +1082,7 @@
   
   nsFontMetricsPS *metrics = NS_REINTERPRET_CAST(nsFontMetricsPS *, mFontMetrics.get());
   NS_ENSURE_TRUE(metrics, NS_ERROR_FAILURE);
-
-#if defined(MOZ_ENABLE_FREETYPE2) || defined(MOZ_ENABLE_XFT)
-  // When FT2 printing is enabled, we don't need to set langgroup
-  if (!NS_REINTERPRET_CAST(nsDeviceContextPS *, mContext.get())->mFTPEnable) {
-#endif
-    nsCOMPtr<nsIAtom> langGroup = nsnull;
-    mFontMetrics->GetLangGroup(getter_AddRefs(langGroup));
-    mPSObj->setlanggroup(langGroup);
-#if defined(MOZ_ENABLE_FREETYPE2) || defined(MOZ_ENABLE_XFT)
-  }
-#endif
-
-  /* build up conversion table */
-  mPSObj->preshow(aString, aLength);
-
-  if (aLength == 0)
-    return NS_OK;
-  nsFontPS* fontPS = nsFontPS::FindFont(aString[0], metrics->Font(), metrics);
-  NS_ENSURE_TRUE(fontPS, NS_ERROR_FAILURE);
-  fontPS->SetupFont(this);
-
-  PRUint32 i, start = 0;
-  for (i=0; i<aLength; i++) {
-    nsFontPS* fontThisChar;
-    fontThisChar = nsFontPS::FindFont(aString[i], metrics->Font(), metrics);
-    NS_ENSURE_TRUE(fontThisChar, NS_ERROR_FAILURE);
-    if (fontThisChar != fontPS) {
-      // draw text up to this point
-      aX += DrawString(aString+start, i-start, aX, aY, fontPS, 
-                       aSpacing?aSpacing+start:nsnull);
-      start = i;
-
-      // setup for following text
-      fontPS = fontThisChar;
-      fontPS->SetupFont(this);
-    }
-  }
-
-  // draw the last part
-  if (aLength-start)
-    DrawString(aString+start, aLength-start, aX, aY, fontPS, 
-               aSpacing?aSpacing+start:nsnull);
-
-  return NS_OK;
-}
-
-PRInt32 
-nsRenderingContextPS::DrawString(const char *aString, PRUint32 aLength,
-                                 nscoord &aX, nscoord &aY, nsFontPS* aFontPS,
-                                 const nscoord* aSpacing)
-{
-  nscoord width = 0;
-  PRInt32 x = aX;
-  PRInt32 y = aY;
-
-  PRInt32 dxMem[500];
-  PRInt32* dx0 = 0;
-  if (aSpacing) {
-    dx0 = dxMem;
-    if (aLength > 500) {
-      dx0 = new PRInt32[aLength];
-      NS_ENSURE_TRUE(dx0, NS_ERROR_OUT_OF_MEMORY);
-    }
-    mTranMatrix->ScaleXCoords(aSpacing, aLength, dx0);
-  }
-
-  mTranMatrix->TransformCoord(&x, &y);
-  width = aFontPS->DrawString(this, x, y, aString, aLength);
-
-  if ((aSpacing) && (dx0 != dxMem)) {
-    delete [] dx0;
-  }
-
-  return width;
-}
-
-
-PRInt32 
-nsRenderingContextPS::DrawString(const PRUnichar *aString, PRUint32 aLength,
-                                 nscoord aX, nscoord aY, nsFontPS* aFontPS,
-                                 const nscoord* aSpacing)
-{
-  nscoord width = 0;
-  PRInt32 x = aX;
-  PRInt32 y = aY;
-
-  if (aSpacing) {
-    // Slow, but accurate rendering
-    const PRUnichar* end = aString + aLength;
-    while (aString < end){
-      x = aX;
-      y = aY;
-      mTranMatrix->TransformCoord(&x, &y);
-      aFontPS->DrawString(this, x, y, aString, 1);
-      aX += *aSpacing++;
-      aString++;
-    }
-    width = aX;
-  } else {
-    mTranMatrix->TransformCoord(&x, &y);
-    width = aFontPS->DrawString(this, x, y, aString, aLength);
-  }
-
-  return width;
+  return metrics->DrawString (aString, aLength, aX, aY, aFontID, aSpacing, this);
 }
 
 /** ---------------------------------------------------
@@ -1346,8 +1196,10 @@
                                          PRUint32           aLength,
                                          nsBoundingMetrics& aBoundingMetrics)
 {
-  // Fill me up 
-  return NS_ERROR_NOT_IMPLEMENTED;
+  NS_ENSURE_TRUE(mFontMetrics, NS_ERROR_NULL_POINTER);
+  nsFontMetricsPS *metrics = NS_REINTERPRET_CAST(nsFontMetricsPS *, mFontMetrics.get());
+  NS_ENSURE_TRUE(metrics, NS_ERROR_FAILURE);
+  return metrics->GetBoundingMetrics (aString, aLength, aBoundingMetrics);
 }
 
   /**
@@ -1359,8 +1211,10 @@
                                          nsBoundingMetrics& aBoundingMetrics,
                                          PRInt32*           aFontID)
 {
-  // Fill me up 
-  return NS_ERROR_NOT_IMPLEMENTED;
+  NS_ENSURE_TRUE(mFontMetrics, NS_ERROR_NULL_POINTER);
+  nsFontMetricsPS *metrics = NS_REINTERPRET_CAST(nsFontMetricsPS *, mFontMetrics.get());
+  NS_ENSURE_TRUE(metrics, NS_ERROR_FAILURE);
+  return metrics->GetBoundingMetrics (aString, aLength, aBoundingMetrics, aFontID);
 }
 #endif /* MOZ_MATHML */
 
--- mozilla/gfx/src/ps/Makefile.in.pango-printing	2006-12-01 16:25:26.000000000 -0500
+++ mozilla/gfx/src/ps/Makefile.in	2006-12-01 16:26:27.000000000 -0500
@@ -98,13 +98,23 @@
 		$(MOZ_UNICHARUTIL_LIBS) \
 		$(NULL)
 
+ifdef MOZ_ENABLE_PANGO
+CPPSRCS		+= \
+		nsFontMetricsPango.cpp \
+		mozilla-decoder.cpp
+EXTRA_DSO_LDOPTS += $(MOZ_PANGO_LIBS)
+CXXFLAGS	+= $(MOZ_PANGO_CFLAGS)
+CFLAGS		+= $(MOZ_PANGO_CFLAGS)
+DEFINES		+= -DPSPANGO
+endif
+
 ifdef MOZ_ENABLE_XFT
 EXTRA_DSO_LDOPTS += \
 		$(MOZ_XFT_LIBS) \
 		$(NULL)
 endif
 
-ifneq (,$(MOZ_ENABLE_FREETYPE2)$(MOZ_ENABLE_XFT))
+ifneq (,$(MOZ_ENABLE_FREETYPE2)$(MOZ_ENABLE_XFT)$(MOZ_ENABLE_PANGO))
 CPPSRCS		+= \
 		nsType1.cpp \
 		$(NULL)
--- mozilla/gfx/src/ps/nsType1.cpp.pango-printing	2006-12-01 16:23:16.000000000 -0500
+++ mozilla/gfx/src/ps/nsType1.cpp	2006-12-01 16:26:27.000000000 -0500
@@ -73,8 +73,13 @@
 #include "nsIFreeType2.h"
 #include "nsServiceManagerUtils.h"
 #endif
+#if defined(MOZ_ENABLE_XFT) || defined(MOZ_ENABLE_PANGO)
+#include FT_TYPE1_TABLES_H
+#endif
 #include "nsPrintfCString.h"
 #include "nsAutoBuffer.h"
+#include "nsValueArray.h"
+#include "nsVoidArray.h"
 
 #define HEXASCII_LINE_LEN 64
 
@@ -113,7 +118,7 @@
                              const char *aBuf, PRInt32 aLen = -1);
 static void charStringOut(FILE* aFile, PRUint32* aPos, PRUint16* aKey,
                           const char *aStr, PRUint32 aLen, 
-                          PRUnichar aId);
+                          const char *aGlyphName);
 static void flattenName(nsCString& aString);
 
 /* thunk a short name for this function */
@@ -202,19 +207,30 @@
     aOutBuf[i] = Type1Encrypt(aInBuf[i], &key);
 }
 
+static FT_UShort
+get_upm (FT_Face face)
+{
+  FT_UShort upm = face->units_per_EM;
+
+  if (!upm)
+    upm = 1000; // bitmap font or something
+
+  return upm;
+}
+
 static PRBool
 sideWidthAndBearing(const FT_Vector *aEndPt, FT2PT1_info *aFti)
 {
   int aw = 0;
   int ah = 0;
-  FT_UShort upm = aFti->face->units_per_EM;
+  FT_UShort upm = get_upm (aFti->face);
   FT_GlyphSlot slot;
   FT_Glyph glyph;
   FT_BBox bbox;
 
   slot = aFti->face->glyph;
 
-#ifdef MOZ_ENABLE_XFT
+#if defined(MOZ_ENABLE_XFT) || defined(MOZ_ENABLE_PANGO)
   FT_Error error = FT_Get_Glyph(slot, &glyph);
   if (error) {
     NS_ERROR("sideWidthAndBearing failed to get glyph");
@@ -256,7 +272,7 @@
 moveto(nsFT_CONST FT_Vector *aEndPt, void *aClosure)
 {
   FT2PT1_info *fti = (FT2PT1_info *)aClosure;
-  FT_UShort upm = fti->face->units_per_EM;
+  FT_UShort upm = get_upm (fti->face);
   PRBool rslt;
 
   if (fti->elm_cnt == 0) {
@@ -293,7 +309,7 @@
 lineto(nsFT_CONST FT_Vector *aEndPt, void *aClosure)
 {
   FT2PT1_info *fti = (FT2PT1_info *)aClosure;
-  FT_UShort upm = fti->face->units_per_EM;
+  FT_UShort upm = get_upm (fti->face);
 
   if (toCS(upm, aEndPt->x) == fti->cur_x) {
     fti->len += ecsi(&fti->buf, toCS(upm, aEndPt->y) - (int)fti->cur_y);
@@ -320,7 +336,7 @@
         void *aClosure)
 {
   FT2PT1_info *ftinfo = (FT2PT1_info *)aClosure;
-  FT_UShort upm = ftinfo->face->units_per_EM;
+  FT_UShort upm = get_upm (ftinfo->face);
   double ctl_x, ctl_y;
   double cur_x, cur_y, x3, y3;
   FT_Vector aControlPt1, aControlPt2;
@@ -353,7 +369,7 @@
         nsFT_CONST FT_Vector *aEndPt, void *aClosure)
 {
   FT2PT1_info *ftinfo = (FT2PT1_info *)aClosure;
-  FT_UShort upm = ftinfo->face->units_per_EM;
+  FT_UShort upm = get_upm (ftinfo->face);
   double cur_x, cur_y, x1, y1, x2, y2, x3, y3;
 
   cur_x = ftinfo->cur_x;
@@ -408,8 +424,55 @@
   0
 };
 
+
+static int
+trace_bitmap_glyph (FT_GlyphSlot slot, FT2PT1_info *fti)
+{
+  unsigned char *row, *byte_ptr, byte;
+  int rows, cols;
+  int x, y, bit_mask;
+  int upm, x_off, y_off, x_mult, y_mult;
+
+  upm = get_upm (slot->face);
+  x_off = slot->bitmap_left;
+  y_off = slot->bitmap_top;
+  x_mult = upm / slot->face->size->metrics.x_ppem;
+  y_mult = upm / slot->face->size->metrics.y_ppem;
+
+  switch (slot->bitmap.pixel_mode) {
+  case FT_PIXEL_MODE_MONO:
+
+    for (y = 0, row = slot->bitmap.buffer, rows = slot->bitmap.rows; rows; row += slot->bitmap.pitch, rows--, y++) {
+	for (x = 0, byte_ptr = row, cols = (slot->bitmap.width + 7) / 8; cols; byte_ptr++, cols--) {
+	    byte = *byte_ptr;
+	    for (bit_mask = 128; bit_mask && x < slot->bitmap.width; bit_mask >>= 1, x++) {
+		if (byte & bit_mask) {
+		    FT_Vector p;
+		    p.x = x_mult * (x_off + x);
+		    p.y = y_mult * (y_off - y);
+		    moveto(&p, (void *) fti);
+		    p.x += x_mult;
+		    lineto(&p, (void *) fti);
+		    p.y += y_mult;
+		    lineto(&p, (void *) fti);
+		    p.x -= x_mult;
+		    lineto(&p, (void *) fti);
+		}
+	    }
+	}
+    }
+    break;
+
+  default:
+    return 1;
+  }
+
+  return 0;
+}
+
+
 FT_Error
-#ifdef MOZ_ENABLE_XFT
+#if defined(MOZ_ENABLE_XFT) || defined(MOZ_ENABLE_PANGO)
 FT2GlyphToType1CharString(FT_Face aFace, PRUint32 aGlyphID,
                           int aWmode, int aLenIV, unsigned char *aBuf)
 #else
@@ -423,7 +486,7 @@
   unsigned char *start = aBuf;
   FT2PT1_info fti;
 
-#ifdef MOZ_ENABLE_XFT
+#if defined(MOZ_ENABLE_XFT) || defined(MOZ_ENABLE_PANGO)
   FT_Error error = FT_Load_Glyph(aFace, aGlyphID, flags);
   if (error) {
     NS_ERROR("failed to load aGlyphID");
@@ -438,11 +501,6 @@
 #endif
   slot = aFace->glyph;
 
-  if (slot->format != ft_glyph_format_outline) {
-    NS_ERROR("aGlyphID is not an outline glyph");
-    return 1;
-  }
-
 #ifdef MOZ_ENABLE_FREETYPE2
   fti.ft2     = aFt2;
 #endif
@@ -456,18 +514,27 @@
   for (j=0; j< aLenIV; j++) {
     fti.len += ecsi(&fti.buf, 0);
   }
-#ifdef MOZ_ENABLE_XFT
-  if (FT_Outline_Decompose(&slot->outline, &ft_outline_funcs, &fti))  {
-    NS_ERROR("error decomposing aGlyphID");
-    return 1;
-  }
+
+  if (slot->format == ft_glyph_format_outline) {
+#if defined(MOZ_ENABLE_XFT) || defined(MOZ_ENABLE_PANGO)
+    if (FT_Outline_Decompose(&slot->outline, &ft_outline_funcs, &fti))  {
+      NS_ERROR("error decomposing aGlyphID");
+      return 1;
+    }
 #else
-  rv = aFt2->OutlineDecompose(&slot->outline, &ft_outline_funcs, &fti);
-  if (NS_FAILED(rv)) {
-    NS_ERROR("error decomposing aGlyphID");
-    return 1;
-  }
+    rv = aFt2->OutlineDecompose(&slot->outline, &ft_outline_funcs, &fti);
+    if (NS_FAILED(rv)) {
+      NS_ERROR("error decomposing aGlyphID");
+    }
 #endif
+  } else if (slot->format == ft_glyph_format_bitmap) {
+    /* ok, it's a bitmap glyph.  trace it! */
+    if (trace_bitmap_glyph (slot, &fti)) {
+      NS_ERROR("error tracing bitmap glyph");
+    }
+  } else {
+      NS_ERROR("aGlyphID has unhandled format");
+  }
 
   if (fti.elm_cnt) {
     fti.len += csc(&fti.buf, T1_CLOSEPATH);
@@ -491,28 +558,52 @@
 }
 
 static PRBool
-#ifdef MOZ_ENABLE_XFT
+#if defined(MOZ_ENABLE_XFT) || defined(MOZ_ENABLE_PANGO)
 outputType1SubFont(FT_Face aFace,
 #else
 outputType1SubFont(nsIFreeType2 *aFt2, FT_Face aFace,
 #endif
-                 const nsAString &aCharIDs, const char *aFontName,
-                 int aWmode, int aLenIV, FILE *aFile);
+                   nsValueArray *aGlyphs,
+                   PRUint32 aOffset, PRUint32 aLen,
+                   const char *aFontName,
+                   int aWmode, int aLenIV, FILE *aFile);
 
 nsresult
 FT2ToType1FontName(FT_Face aFace, int aWmode, nsCString& aFontName)
 {
+  // only hash the first 10 000 bytes of the font
+  int size = aFace->stream->size;
+  size = size > 10000 ? 10000 : size;
+
+  unsigned char *data;
+  if (aFace->stream->read) {
+    data = (unsigned char *) malloc (size);
+    aFace->stream->read (aFace->stream, 0, data, size);
+  } else {
+    data = aFace->stream->base;
+  }
+
+  unsigned int data_hash = 0;
+  int i;
+  for (i = 0; i < size; i++)
+    data_hash = (data_hash << 5) - data_hash + data[size];
+
+  if (aFace->stream->read)
+    free (data);
+
   aFontName = aFace->family_name;
   aFontName.AppendLiteral(".");
   aFontName += aFace->style_name;
-  aFontName += nsPrintfCString(".%ld.%d", aFace->face_index, aWmode ? 1 : 0);
+  aFontName += nsPrintfCString(".%ld.%d.%lx.%x", aFace->face_index, aWmode ? 1 : 0,
+                               (long) aFace->stream->size, data_hash);
   flattenName(aFontName);
+
   return NS_OK;
 }
 
 // output a subsetted truetype font converted to multiple type 1 fonts
 PRBool
-FT2SubsetToType1FontSet(FT_Face aFace, const nsString& aSubset,
+FT2SubsetToType1FontSet(FT_Face aFace, nsValueArray *aGlyphSubset,
                         int aWmode,  FILE *aFile)
 {
 #ifdef MOZ_ENABLE_FREETYPE2
@@ -527,32 +618,35 @@
   nsCAutoString fontNameBase;
   FT2ToType1FontName(aFace, aWmode, fontNameBase);
   PRUint32 i = 0;
-  for (; i <= aSubset.Length() / 255 ; i++) {
+  for (; i <= aGlyphSubset->Count() / 255 ; i++) {
     nsCAutoString fontName(fontNameBase);
     fontName.AppendLiteral(".Set");
     fontName.AppendInt(i);
-#ifdef MOZ_ENABLE_XFT
+#if defined(MOZ_ENABLE_XFT) || defined(MOZ_ENABLE_PANGO)
     outputType1SubFont(aFace,
 #else
     outputType1SubFont(ft2, aFace, 
 #endif
-      Substring(aSubset, i * 255, PR_MIN(255, aSubset.Length() - i * 255)),
-      fontName.get(), aWmode, 4, aFile);
+                       aGlyphSubset,
+                       (i * 255), PR_MIN(255, aGlyphSubset->Count() - i * 255),
+                       fontName.get(), aWmode, 4, aFile);
   }
   return PR_TRUE;
 }
 
 // output a type 1 font (with 255 characters or fewer) 
 static PRBool
-#ifdef MOZ_ENABLE_XFT
+#if defined(MOZ_ENABLE_XFT) || defined(MOZ_ENABLE_PANGO)
 outputType1SubFont(FT_Face aFace,
 #else
 outputType1SubFont(nsIFreeType2 *aFt2, FT_Face aFace,
 #endif
-                 const nsAString& aCharIDs, const char *aFontName,
-                 int aWmode, int aLenIV, FILE *aFile)
+                   nsValueArray *aGlyphs,
+                   PRUint32 aOffset, PRUint32 aLen,
+                   const char *aFontName,
+                   int aWmode, int aLenIV, FILE *aFile)
 {
-  FT_UShort upm = aFace->units_per_EM;
+  FT_UShort upm = get_upm (aFace);
 
   fprintf(aFile, "%%%%BeginResource: font %s\n"
                  "%%!PS-AdobeFont-1.0-3.0 %s 1.0\n"
@@ -573,9 +667,13 @@
                  toCS(upm, aFace->bbox.xMax),
                  toCS(upm, aFace->bbox.yMax));
 
-  nsString charIDstr(aCharIDs);
-  PRUint32 len = aCharIDs.Length();
-  
+  nsValueArray glyphs(PR_UINT16_MAX);
+  nsCStringArray glyphnames(PR_UINT16_MAX);
+  glyphs = *aGlyphs;
+
+  PRUint32 len = aLen;
+  PRUint32 i;
+
   if (len < 10) { 
     // Add a small set of characters to the subset of the user
     // defined font to produce to make sure the font ends up
@@ -584,25 +682,47 @@
     // XXX : need to check if this is true of type 1 fonts as well.
     // I suspect it's only the case of CID-keyed fonts (type 9) we used to
     // generate. 
-    charIDstr.AppendLiteral("1234567890"); 
+    for (i = 1; i <= 10; i++) {
+      glyphs.AppendValue(i);
+    }
     len += 10;
   }
   
-  const PRUnichar *charIDs = charIDstr.get();
-
-  PRUint32 i;
+  FT_Int has_glyph_name;
+#if defined (MOZ_ENABLE_XFT) || defined (MOZ_ENABLE_PANGO)
+  has_glyph_name = FT_Has_PS_Glyph_Names(aFace);
+#else
+  has_glyph_name = aFt2->hasPSGlyphNames(aFace);
+#endif
 
   // construct an Encoding vector : the 0th element
   // is /.notdef
-  fputs("/Encoding [\n/.notdef\n", aFile); 
-  for (i = 0; i < len; ++i) {
-      fprintf(aFile, "/uni%04X", charIDs[i]); 
-      if (i % 8 == 7) fputc('\n', aFile);
+  fputs("/Encoding [\n/.notdef", aFile); 
+  for (i = aOffset; i < aOffset + aLen; ++i) {
+      nsCString name;
+      char buffer[256];
+
+      if (glyphs.ValueAt(i) == 0) {
+        name = "/.notdef";
+      } else if (!has_glyph_name ||
+#if defined (MOZ_ENABLE_XFT) || defined (MOZ_ENABLE_PANGO)
+                 FT_Get_Glyph_Name(aFace, glyphs.ValueAt(i), buffer, 255) != FT_Err_Ok
+#else
+                 NS_FAILED(aFt2->getGlyphName(aFace, glyphs.ValueAt(i), buffer, 255))
+#endif
+      ) {
+        name = nsPrintfCString(256, "/idx%04X", glyphs.ValueAt(i));
+      } else {
+        name = nsPrintfCString(256, "/%s", buffer);
+      }
+      glyphnames.AppendCString(name);
+      fprintf(aFile, name.get());
+      if ((i-aOffset) % 8 == 6) fputc('\n', aFile);
   }
 
-  for (i = len; i < 255; ++i) {
+  for (i = PR_MAX (0, 255 - int(aLen)); i; --i) {
       fputs("/.notdef", aFile);
-      if (i % 8 == 7) fputc('\n', aFile);
+      if (i % 8 == 1) fputc('\n', aFile);
   }
   fputs("] def\n", aFile); 
 
@@ -630,23 +750,21 @@
   // get the maximum charstring length without actually filling up the buffer
   PRInt32 charStringLen;
   PRInt32 maxCharStringLen =
-#ifdef MOZ_ENABLE_XFT
+#if defined(MOZ_ENABLE_XFT) || defined(MOZ_ENABLE_PANGO)
     FT2GlyphToType1CharString(aFace, 0, aWmode, aLenIV, nsnull);
 #else
     FT2GlyphToType1CharString(aFt2, aFace, 0, aWmode, aLenIV, nsnull);
 #endif
 
-  PRUint32 glyphID;
-
-  for (i = 0; i < len; i++) {
-#ifdef MOZ_ENABLE_XFT
-    glyphID = FT_Get_Char_Index(aFace, charIDs[i]);
+  for (i = aOffset; i < aOffset + aLen; i++) {
+#if defined(MOZ_ENABLE_XFT) || defined(MOZ_ENABLE_PANGO)
     charStringLen =
-      FT2GlyphToType1CharString(aFace, glyphID, aWmode, aLenIV, nsnull);
+      FT2GlyphToType1CharString(aFace, glyphs.ValueAt(i), aWmode, aLenIV,
+                                nsnull);
 #else
-    aFt2->GetCharIndex(aFace, charIDs[i], &glyphID);
     charStringLen =
-      FT2GlyphToType1CharString(aFt2, aFace, glyphID, aWmode, aLenIV, nsnull);
+      FT2GlyphToType1CharString(aFt2, aFace, glyphs.ValueAt(i), aWmode, aLenIV,
+                                nsnull);
 #endif
 
     if (charStringLen > maxCharStringLen)
@@ -666,7 +784,7 @@
                                    len + 1).get()); 
 
   // output the notdef glyph
-#ifdef MOZ_ENABLE_XFT
+#if defined(MOZ_ENABLE_XFT) || defined(MOZ_ENABLE_PANGO)
   charStringLen = FT2GlyphToType1CharString(aFace, 0, aWmode, aLenIV,
                                             charString.get());
 #else
@@ -676,22 +794,20 @@
 
   // enclose charString with  "/.notdef RD .....  ND" 
   charStringOut(aFile, &pos, &key, NS_REINTERPRET_CAST(const char*, charString.get()),
-                charStringLen, 0); 
+                charStringLen, "/.notdef");
 
 
   // output the charstrings for each glyph in this sub font
-  for (i = 0; i < len; i++) {
-#ifdef MOZ_ENABLE_XFT
-    glyphID = FT_Get_Char_Index(aFace, charIDs[i]);
-    charStringLen = FT2GlyphToType1CharString(aFace, glyphID, aWmode,
+  for (i = aOffset; i < aOffset + aLen; i++) {
+#if defined(MOZ_ENABLE_XFT) || defined(MOZ_ENABLE_PANGO)
+    charStringLen = FT2GlyphToType1CharString(aFace, glyphs.ValueAt(i), aWmode,
                                               aLenIV, charString.get());
 #else
-    aFt2->GetCharIndex(aFace, charIDs[i], &glyphID);
-    charStringLen = FT2GlyphToType1CharString(aFt2, aFace, glyphID, aWmode,
-                                              aLenIV, charString.get());
+    charStringLen = FT2GlyphToType1CharString(aFt2, aFace, glyphs.ValueAt(i),
+                                              aWmode, aLenIV, charString.get());
 #endif
     charStringOut(aFile, &pos, &key, NS_REINTERPRET_CAST(const char*, charString.get()),
-                  charStringLen, charIDs[i]);
+                  charStringLen, glyphnames.CStringAt(i - aOffset)->get());
   }
 
   // wrap up the encrypted part of the font definition
@@ -753,15 +869,12 @@
 
 /* static */ 
 void charStringOut(FILE* aFile,  PRUint32* aPos, PRUint16* aKey, 
-                   const char *aStr, PRUint32 aLen, PRUnichar aId)
+                   const char *aStr, PRUint32 aLen, const char *aGlyphName)
 {
     // use a local buffer instead of nsPrintfCString to avoid alloc.
     char buf[30];
     int oLen;
-    if (aId == 0)
-      oLen = PR_snprintf(buf, 30, "/.notdef %d RD ", aLen); 
-    else 
-      oLen = PR_snprintf(buf, 30, "/uni%04X %d RD ", aId, aLen); 
+    oLen = PR_snprintf(buf, 30, "%s %d RD ", aGlyphName, aLen);
 
     if (oLen >= 30) {
       NS_WARNING("buffer size exceeded. charstring will be truncated");
--- mozilla/gfx/src/ps/nsDeviceContextPS.cpp.pango-printing	2006-12-01 16:23:16.000000000 -0500
+++ mozilla/gfx/src/ps/nsDeviceContextPS.cpp	2006-12-01 16:26:27.000000000 -0500
@@ -58,12 +58,15 @@
 #include "nsIPref.h"
 #include "nsString.h"
 #include "nsFontMetricsPS.h"
+#ifdef MOZ_ENABLE_PANGO
+#include "nsFontMetricsPango.h"
+#endif
 #include "nsPostScriptObj.h"
 #include "nspr.h"
 #include "nsILanguageAtomService.h"
 #include "nsPrintJobPS.h"
 #include "nsPrintJobFactoryPS.h"
-#if defined(MOZ_ENABLE_FREETYPE2) || defined(MOZ_ENABLE_XFT)
+#if defined(MOZ_ENABLE_FREETYPE2) || defined(MOZ_ENABLE_XFT) || defined(MOZ_ENABLE_PANGO)
 #include "nsType1.h"
 #endif
 
@@ -223,7 +226,7 @@
  
   nsresult rv;
   nsCOMPtr<nsIPref> pref(do_GetService(NS_PREF_CONTRACTID, &rv));
-#ifdef MOZ_ENABLE_XFT
+#if defined(MOZ_ENABLE_XFT) || defined(MOZ_ENABLE_PANGO)
   if (NS_SUCCEEDED(rv)) {
       rv = pref->GetBoolPref("font.FreeType2.printing", &mFTPEnable);
       if (NS_FAILED(rv))
@@ -469,7 +472,7 @@
       NS_ASSERTION(submitFP, "No print job submission handle");
 
       // Start writing the print job to the job handler
-#if defined(MOZ_ENABLE_FREETYPE2) || defined(MOZ_ENABLE_XFT)
+#if defined(MOZ_ENABLE_FREETYPE2) || defined(MOZ_ENABLE_XFT) || defined(MOZ_ENABLE_PANGO)
       mPSObj->write_prolog(submitFP, mFTPEnable);
 #else 
       mPSObj->write_prolog(submitFP);
@@ -550,15 +553,52 @@
   virtual nsresult CreateFontMetricsInstance(nsIFontMetrics** aResult);
 };
 
+#if defined(MOZ_ENABLE_PANGO)
+PRBool
+NS_IsPangoEnabled(void)
+{
+    static PRBool beenHere;
+    static PRBool pangoEnabled;
+
+    if (!beenHere) {
+        beenHere = PR_TRUE;
+
+        char *val = PR_GetEnv("MOZ_DISABLE_PANGO");
+        pangoEnabled = !(val);
+
+        if (pangoEnabled) {
+            nsCOMPtr<nsIPref> prefService = do_GetService(NS_PREF_CONTRACTID);
+            if (prefService)
+                prefService->SetDefaultCharPref("general.useragent.extra.pango",
+                                                "pango-text");
+        }
+    }
+
+    return pangoEnabled;
+}
+#endif
 
 nsresult nsFontCachePS::CreateFontMetricsInstance(nsIFontMetrics** aResult)
 {
   NS_PRECONDITION(aResult, "null out param");
-  nsIFontMetrics *fm = new nsFontMetricsPS();
-  if (!fm)
-    return NS_ERROR_OUT_OF_MEMORY;
-  NS_ADDREF(fm);
-  *aResult = fm;
+#ifdef MOZ_ENABLE_PANGO
+  if (NS_IsPangoEnabled())
+  {
+    nsIFontMetrics *fm = new nsFontMetricsPSPango();
+    if (!fm)
+      return NS_ERROR_OUT_OF_MEMORY;
+    NS_ADDREF(fm);
+    *aResult = fm;
+  }
+  else
+#endif
+  {
+    nsIFontMetrics *fm = new nsFontMetricsPS();
+    if (!fm)
+      return NS_ERROR_OUT_OF_MEMORY;
+    NS_ADDREF(fm);
+    *aResult = fm;
+  }
   return NS_OK;
 }
 
Index: mozilla/config/system-headers
===================================================================
--- mozilla/config/system-headers	2006-10-26 12:21:39.000000000 -0400
+++ mozilla/config/system-headers	2006-10-26 12:23:29.000000000 -0400
@@ -180,6 +180,7 @@
 freetype/ftoutln.h
 freetype/ttnameid.h
 freetype/tttables.h
+freetype/t1tables.h
 fribidi/fribidi.h
 FSp_fopen.h
 fstream.h
@@ -484,6 +485,7 @@
 pango/pangofc-fontmap.h
 pango/pango-fontmap.h
 pango/pango.h
+pango/pangoft2.h
 pango/pangoxft.h
 pango/pangox.h
 pango-types.h
